{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../App.svelte",
    "../Component.svelte",
    "../ListeDebit.svelte",
    "../Settings.svelte",
    "../TreeItem.svelte",
    "../InputSelect.svelte",
    "../Caisson.svelte",
    "../Etagere.svelte",
    "../Facade.svelte",
    "../Porte.svelte",
    "../Tiroir.svelte"
  ],
  "sourcesContent": [
    "<script>\n  import { setContext } from 'svelte';\n  import { readable, writable, get } from 'svelte/store';\n  import { routeDeclare } from './route.js';\n  import Settings from './Settings.svelte';\n  import TreeItem from './TreeItem.svelte';\n  import TreeItemOption from './TreeItemOption.svelte';\n  import Ensemble from './ensembles/Ensemble.svelte';\n  import Porte from './ensembles/Porte.svelte';\n  import Caisson from './ensembles/Caisson.svelte';\n  import Etagere from './ensembles/Etagere.svelte';\n  import Facade from './ensembles/Facade.svelte';\n  import Tiroir from './ensembles/Tiroir.svelte';\n  let components = { Porte, Caisson, Ensemble, Etagere, Facade, Tiroir }\n\n  setContext('App-components',  components)\n\n  let filename = `meuble_${new Date().toISOString().slice(0,16).replace(/T/, '_').replace(/:/, '')}.json`\n  let initdata = {}\n  let data = {}\n\n  $: data = {...initdata}\n\n  $: console.log('App initdata =', initdata)\n  //$: console.log('App data =', data)\n\n  let agencement = 'horizontal'\n\n  let settings = writable(JSON.parse(localStorage.getItem('calcul-meubles-settings') || '{}'))\n  setContext('settings', settings)\n  settings.subscribe(settings => {\n    if(settings.agencement && agencement != settings.agencement) agencement = settings.agencement\n    //console.log(\"App data.settings =\")\n    data.settings = settings\n    localStorage.setItem('calcul-meubles-settings', JSON.stringify(settings))\n  })\n  $: settings.update(settings => ({\n      ...settings,\n      agencement: agencement,\n    }))\n\n  let item = JSON.parse(localStorage.getItem('calcul-meubles-data') || 'null')\n  let fileData = localStorage.getItem('calcul-meubles-file-data')\n  if(item) {\n    initdata = item.data\n    filename = item.filename\n  }\n\n  $: localStorage.setItem('calcul-meubles-data', JSON.stringify({data: data, filename: filename}))\n  $: localStorage.setItem('calcul-meubles-file-data', fileData)\n\n  function clear(){\n    if(!isSaved()) {\n      if(!confirm(\"Fichier non enregistré, voulez-vous continuer et perdre les modifications en cours?\")) return\n      localStorage.setItem('calcul-meubles-data-backup', localStorage.getItem('calcul-meubles-data'))\n      localStorage.setItem('calcul-meubles-file-data-backup', localStorage.getItem('calcul-meubles-file-data'))\n    }\n    localStorage.removeItem('calcul-meubles-data')\n    localStorage.removeItem('calcul-meubles-file-data')\n    window.location.reload()\n  }\n\n  function rename(){\n    let new_filename = prompt(\"Nom du fichier\", filename)\n    if (new_filename == null) return false\n    filename = new_filename\n    return true\n  }\n\n  function saveAs(){\n    save(true)\n  }\n\n  function ensureSaved(){\n    let item = localStorage.getItem('calcul-meubles-data')\n    if (item) {\n      if(save(false) == 'cancelled') return false;\n    }\n    return true;\n  }\n\n  function isSaved(){\n    if(data.children.length == 0) return true;\n    let json = JSON.stringify(data, null, 2)\n    if (json == fileData) return true;\n    console.log(\"isSaved() = false\", json, fileData)\n    return false;\n  }\n\n  function simpleSave(){\n    if(save(false) == 'already-saved') {\n      alert(\"Déjà enregistré\")\n    }\n  }\n\n  function save(saveAs){\n    if(!saveAs && isSaved()){\n      return 'already-saved';\n    }\n    let json = JSON.stringify(data, null, 2)\n\n    if(saveAs && !rename()) return 'cancelled';\n\n    let file = new window.File([json], filename, {\n      type: 'application/json'\n    })\n    let url = URL.createObjectURL(file);\n\n    try {\n      let a = document.createElement('a');\n      a.href = url;\n      a.style.display = 'none';\n      a.setAttribute('download', filename);\n\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n\n      localStorage.removeItem('calcul-meubles-data')\n      fileData = json\n    } finally {\n      URL.revokeObjectURL(url)\n    }\n  }\n\n  function open(){\n    if(!isSaved()) {\n      alert(\"Fichier non enregistré, veuillez enregistrer le fichier avant d'en ouvrir un nouveau.\")\n      return\n    }\n    let input = document.createElement('input');\n    input.style.display = 'none';\n    input.setAttribute('type', 'file')\n    input.addEventListener('change', (e) => {\n      let file = e.target.files[0];\n      if (!file) return\n\n      let reader = new FileReader();\n      reader.onload = (e) => {\n        initdata = JSON.parse(e.target.result)\n        settings.set(initdata.settings || {})\n        filename = file.name\n        fileData = e.target.result\n      }\n      reader.readAsText(file);\n    }, false)\n\n    document.body.appendChild(input);\n    input.click();\n    document.body.removeChild(input);\n  }\n\n  function moveTree(e){\n    window.location.hash = e.target.value\n  }\n\n  function openSettings(){\n    window.location.hash = '#/settings'\n  }\n\n  let root_target;\n  routeDeclare((route) => {\n    return route.root ? [root_target] : []\n  })\n\n  function onDataChange(e) {\n    //console.log(`App datachange{${Object.keys(e.detail).join()}} = %o`, e.detail);\n    data = e.detail.data\n  }\n</script>\n\n<style>\n  button, select {\n    margin: 0;\n  }\n  .tree button, .tree select {\n    padding: 1px;\n  }\n  .root {\n    display: flex;\n    grid-template-rows: 3rem auto;\n    grid-template-columns: minmax(0, 1fr) auto;\n    grid-template-areas:\n      \"toolbar toolbar\"\n      \"tree main\";\n    flex-flow: row nowrap;\n    height: 100%\n  }\n  .agencement-horizontal.root {\n    display: grid;\n    grid-template-columns: auto;\n    grid-template-areas:\n      \"toolbar\"\n      \"main\";\n  }\n  .root.agencement-vertical .tree {\n    flex: 0 0 auto\n  }\n  .toolbar {\n    padding: 4px;\n    grid-area: toolbar;\n    background-color: var(--light-bg-color);\n    border-bottom: solid 1px var(--border-color);\n  }\n  .open-save-buttons {\n    display: grid;\n    align-content: stretch;\n    grid-template-rows: repeat(2, 50fr);\n    grid-template-columns: repeat(2, auto);\n  }\n  .tree {\n    grid-area: tree;\n    background-color: var(--light-bg-color);\n    border-right: solid 1px var(--border-color);\n    overflow: auto;\n    width: 15rem;\n    resize: horizontal;\n  }\n  .tree :global(ul) {\n    padding-left: 1em;\n  }\n  .tree :global(ul) :global(ul) {\n    /*border-left: solid 1px var(--border-color);*/\n  }\n  .agencement-horizontal .tree {\n    display: none;\n  }\n  .root.agencement-vertical .tree-select {\n    display: none;\n  }\n  .main {\n    flex: 1 1 auto;\n    grid-area: main;\n    overflow: auto;\n    justify-self: stretch;\n  }\n\n  @media print {\n    .root, .main {\n      display: block !important;\n      overflow: visible !important;\n      height: auto;\n    }\n  }\n</style>\n\n<div class=\"root agencement-{agencement}\">\n\n  {#if agencement == 'horizontal'}\n  <div class=\"toolbar\">\n    <select on:change={moveTree} class=\"tree-select\">\n      <option value='#/settings'>Paramètres</option>\n      <TreeItemOption data={data}/>\n    </select>\n    <button on:click={clear}>Effacer</button>\n    <button on:click={simpleSave}>Enregistrer</button>\n    <button on:click={saveAs}>Enregistrer sous...</button>\n    <button on:click={open}>Ouvrir...</button>\n    {filename} <a href=\"@\" on:click|preventDefault={rename}>✎</a>\n    <div style=\"float: right\">\n      <label style=\"display: inline\">\n        Agencement :\n        <select bind:value={agencement}>\n          <option value='horizontal'>Horizontal</option>\n          <option value='vertical'>Vertical</option>\n        </select>\n      </label>\n      <button on:click={openSettings}>Paramètres...</button>\n    </div>\n  </div>\n  {/if}\n\n  <div class=\"tree\">\n    {#if agencement == 'vertical'}\n      <div class=\"open-save-buttons\">\n        <select bind:value={agencement}>\n          <option value='horizontal'>Agencement horizontal</option>\n          <option value='vertical'>Agencement vertical</option>\n        </select>\n        <button on:click={openSettings}>Paramètres...</button>\n        <button on:click={simpleSave}>Enregistrer</button>\n        <button on:click={saveAs}>Enregistrer sous...</button>\n        <button on:click={clear}>Nouveau</button>\n        <button on:click={open}>Ouvrir...</button>\n      </div>\n      <p>{filename} <a href=\"@\" on:click|preventDefault={rename}>✎</a></p>\n    {/if}\n    <ul>\n      <li>\n        <TreeItem data={data}/>\n      </li>\n      {#if agencement == 'vertical'}\n        <li><a href=\"@\" on:click|preventDefault={openSettings}>Paramètres...</a></li>\n      {/if}\n    </ul>\n  </div>\n\n  <div class=\"main\">\n    <Ensemble name=\"Meuble\" initdata={initdata} on:datachange={onDataChange} />\n    <div class=\"routable\" bind:this={root_target}>\n      <details>\n        <summary>Contenu du fichier</summary>\n        <pre id=\"json\">{JSON.stringify(data, null, 2)}</pre>\n      </details>\n    </div>\n    <Settings bind:settings={settings} />\n  </div>\n</div>\n",
    "<script>\n/*\ndata flow:\n\n- root component pass data to child initdata\n- in child:  data = {...initdata, opt, ui, children}\n- child comp pass data to Component\n- when child data changes, Component fires datachange to root\n- child Component pass data.children[i] to grandchild initdata\n- when data changes in grandchild comp, child Component set it to children\n- children is passed from Component to child element\n- child element recomputes data\n- child Component pass updated data to parent\n\n*/\n\n  import { getContext, setContext, createEventDispatcher } from 'svelte';\n  import { routeDeclare } from './route.js';\n  import { nextId } from './utils.js';\n\n  const dispatch = createEventDispatcher();\n  let components = getContext('App-components')\n  let layout = 'all';\n  getContext('settings').subscribe(settings => {\n    layout = settings.component_layout\n  })\n\n  export let data\n  export let state = {}\n  export let childrenState = []\n  export let children = data.children || []\n  export let path = `${getContext('Component-path')}-${data.id}`\n\n  /*\n  $: console.log(`Component ${data.type}(${path}) data =`, data)\n  $: console.log(`Component ${data.type}(${path}) state =`, state)\n  $: console.log(`Component ${data.type}(${path}) childrenState =`, childrenState)\n  $: console.log(`Component ${data.type}(${path}) children =`, children)\n  $: console.log(`Component ${data.type}(${path}) path =`, path)\n  */\n\n  setContext('Component-path', path)\n\n  dispatch('datachange', {data, state})\n  //$: dispatch('datachange', {data})\n  //$: dispatch('datachange', {state})\n  //$: console.log(`${data.type}(${path}) datachange!`), dispatch('datachange', {state, data})\n  $: dispatchDatachange(state, data)\n\n  function dispatchDatachange(state, data){\n    //console.log(`${data.type}(${path}) datachange!`)\n    dispatch('datachange', {state, data})\n  }\n\n  function renameChild(i){\n    let name = prompt(`Renommer \"${children[i].name}\" en :`, children[i].name) || children[i].name\n    children[i].name = name\n  }\n\n  function deleteChild(i){\n    if(!confirm(`Supprimer ${children[i].name} ?`)) return\n    let children2 = [...children]\n    children2.splice(i, 1)\n    console.log(\"delete\", i, children, children2)\n    children = children2\n  }\n\n  function onDataChange(e, i){\n    //console.log(`${data.type}(${path}).children[${i}] datachange{${Object.keys(e.detail).join()}} = %o`, e.detail);\n    if(e.detail.data)  children[i] = e.detail.data\n    if(e.detail.state) childrenState[i] = e.detail.state\n  }\n\n  // manually set target class because when svelte modified an element class\n  // list, it removes any manually set classes with the classList API.\n  let target = false\n  routeDeclare(route => {\n    target = (route.component_path == path)\n  })\n\n  function setLayout(e, name){\n    if(e) e.preventDefault()\n    layout = name\n    getContext('settings').update(settings => ({\n      ...settings,\n      component_layout: layout,\n    }))\n  }\n\n  function addChild(type){\n    let id = nextId(children)\n    let name = prompt(\"Nom du sous-ensemble :\", `${path}-${id}`) || `${path}-${id}`\n    children = [...children, {\n      type: type,\n      name: name,\n      id:   id\n    }]\n  }\n\n</script>\n\n<style>\n  .debug{\n    display: none;\n  }\n  .component.target, .component:target {\n    height: 100%;\n    display: flex;\n    flex-flow: column nowrap;\n  }\n\n  .component-grid {\n    flex: 1 1 auto;\n    height: 100%;\n    overflow: auto;\n  }\n\n  ul.tabs {\n    flex: 0 0 auto;\n    margin: 0;\n    background-color: var(--light-bg-color);\n    border-bottom: solid 1px var(--border-color);\n  }\n  ul.tabs > li:last-child {\n    border-right: solid 1px var(--border-color);\n  }\n  ul.tabs > li {\n    border-top: solid 1px var(--border-color);\n    border-left: solid 1px var(--border-color);\n    margin: 0;\n    padding: 0;\n    margin-top: 2px;\n    display: inline;\n  }\n  ul.tabs > li > a {\n    padding: 0 1em;\n  }\n  ul.tabs > li > a.active {\n    background-color: white;\n  }\n\n  :global(.layout-plan) .component-grid > :not(.component-grid-plan) {\n    display: none;\n  }\n\n  :global(.layout-dim) .component-grid > :not(.component-grid-dim) {\n    display: none;\n  }\n\n  :global(.layout-tables) .component-grid > :not(.component-grid-tables) {\n    display: none;\n  }\n\n  :global(.layout-children) .component-grid > :not(.component-grid-plan):not(.component-grid-children) {\n    display: none;\n  }\n  :global(.layout-children) .component-grid > .component-grid-plan {\n    order: 1;\n    flex: 0 0 auto;\n    display: unset;\n    border-right: solid 1px var(--border-color);\n    overflow: auto;\n    resize: horizontal;\n  }\n  :global(.layout-children) .component-grid > .component-grid-children {\n    order: 2;\n    flex: 1 1 auto;\n    display: unset;\n    overflow: auto;\n  }\n  :global(.layout-children) .component-grid {\n    display: flex;\n    flex-flow: row nowrap;\n  }\n\n  :global(.layout-plan-dim) .component-grid > * {\n    display: none;\n  }\n  :global(.layout-plan-dim) .component-grid > .component-grid-plan {\n    order: 1;\n    flex: 0 0 auto;\n    display: unset;\n    border-right: solid 1px var(--border-color);\n    overflow: auto;\n    resize: horizontal;\n  }\n  :global(.layout-plan-dim) .component-grid > .component-grid-dim {\n    order: 2;\n    flex: 1 1 auto;\n    display: unset;\n    overflow: auto;\n  }\n  :global(.layout-plan-dim) .component-grid {\n    display: flex;\n    flex-flow: row nowrap;\n  }\n\n  @media print {\n    .component, .component-grid, .component-grid > * {\n      display: block !important;\n      overflow: visible !important;\n    }\n  }\n</style>\n\n<div class=\"routable component layout-{layout}\" class:target={target} id=\"component-{path}\">\n  <ul class=\"tabs\">\n    <li><a href=\"@\" on:click={e => setLayout(e, 'all')}      class:active={layout=='all'}>Tout</a></li>\n    <li><a href=\"@\" on:click={e => setLayout(e, 'plan')}     class:active={layout=='plan'}>Plan</a></li>\n    <li><a href=\"@\" on:click={e => setLayout(e, 'plan-dim')} class:active={layout=='plan-dim'}>Plan + Dimensions</a></li>\n    <li><a href=\"@\" on:click={e => setLayout(e, 'dim')}      class:active={layout=='dim'}>Dimensions</a></li>\n    <li><a href=\"@\" on:click={e => setLayout(e, 'tables')}   class:active={layout=='tables'}>Tableaux</a></li>\n    <li><a href=\"@\" on:click={e => setLayout(e, 'children')} class:active={layout=='children'}>Sous-éléments</a></li>\n  </ul>\n  <div class=\"component-grid\">\n    <div class=\"component-grid-plan\">\n      <slot name=\"plan\"></slot>\n    </div>\n    <div class=\"component-grid-dim\">\n      <slot name=\"dim\"></slot>\n    </div>\n    <div class=\"component-grid-main\">\n      <slot></slot>\n    </div>\n    <div class=\"component-grid-tables\">\n      <slot name=\"tables\"></slot>\n    </div>\n\n    <div class=\"component-grid-children\">\n      <slot name=\"children\"></slot>\n\n      <button on:click={e => addChild('Porte')}>Nouvelle porte</button>\n      <button on:click={e => addChild('Caisson')}>Nouveau caisson</button>\n      <button on:click={e => addChild('Etagere')}>Nouvelle étagère</button>\n      <button on:click={e => addChild('Facade')}>Nouvelle façade</button>\n      <button on:click={e => addChild('Tiroir')}>Nouveau tiroir</button>\n      <button on:click={e => addChild('Ensemble')}>Nouveau sous-ensemble</button>\n\n      {#if data.children && data.children.length}\n      <ul>\n      {#each data.children as child, i}\n        {#if child.type}\n        <li>\n          <a href=\"#/component/{path}-{child.id}\">{child.type} {child.name}</a>\n          <a href=\"@\" on:click|preventDefault={e => renameChild(i)}>✎</a>\n          <a href=\"@\" on:click|preventDefault={e => deleteChild(i)}>🗑</a>\n        </li>\n        {/if}\n      {/each}\n      </ul>\n      {/if}\n    </div>\n  </div>\n  <!--\n  <details>\n    <summary>data</summary>\n    <pre>JSON.stringify(data, null, 2)</pre>\n  </details>\n  -->\n</div>\n\n\n{#if data.children && data.children.length}\n{#each data.children as child, i}\n  <svelte:component\n    this={components[child.type]}\n    initdata={child}\n    on:datachange={e => onDataChange(e, i)}\n    path=\"{path}-{child.id}\" />\n{/each}\n{/if}\n",
    "<script>\n  import { getContext } from 'svelte';\n  import { reduceToObject } from './utils.js';\n  import Group from './pieces/Group.js';\n  import Estimation from './Estimation.svelte'\n\n  export let pieces = []\n  export let merge = true\n  export let estimations\n\n  let separer = true\n  let totaux = true\n  let par_epaiss = false\n  let par_type = true\n\n  function comparePieces(p1, p2) {\n    return (\n      (p1.epaisseur < p2.epaisseur) ?  1 :\n      (p1.epaisseur > p2.epaisseur) ? -1 :\n      (p1.longueur  < p2.longueur)  ?  1 :\n      (p1.longueur  > p2.longueur)  ? -1 :\n      (p1.largeur   < p2.largeur)   ?  1 :\n      (p1.largeur   > p2.largeur)   ? -1 : 0);\n  }\n\n  // Pièces, tableau non fusionné\n  $: pieces2 = pieces.pieces\n    .reduce((res, p) => res.concat(p.individual()), [])\n    .map((p) => (\n      (!p.piece) ? p : p.piece.update_new({\n        ...p.piece,\n        names: p.nom ? p.nom.split(' ') : p.piece.names,\n        que: quantite * (p.que || p.piece.que || 1),\n      })\n    ))\n    .sort(comparePieces)\n\n  // Pièces, tableau fusionné si merge == true\n  $: pieces3 = !merge ? pieces2 :\n    Object.values(pieces2.reduce((map, p) => (map[p.signature()] = [...(map[p.signature()] || []), p], map), {}))\n    .map(family => (\n      family.reduce((a, b) => (a == null ? b : a.merge(b)), null)\n    ))\n    .sort(comparePieces)\n\n  let cubeprice\n  let cubemargin\n  getContext('settings').subscribe(settings => {\n    cubeprice = settings.cubeprice\n    cubemargin = settings.cubemargin\n  })\n\n  $: total_cube = pieces3.map(p => p.que * p.cubage(cubemargin/100)).reduce((a, b) => (a+b), 0)\n  $: total_prix = pieces3.map(p => p.que * p.prix(cubeprice, cubemargin/100)).reduce((a, b) => (a+b), 0)\n\n  let statistics = []\n  $: statistics = calculStatistics(pieces, totaux)\n  $: statistics_epaisseurs = Object.keys(statistics\n    .reduce((h,x) => {x.epaisseurs.forEach(ep => h[ep.epaisseur] = true); return h}, {}))\n\n  function calculStatistics(total_group, totaux){\n    //console.log(\"calculStatistics!!!!\", total_group.individual().map(p => p.features))\n    return total_group\n      .flat_groups('', totaux)\n      .map(group => {\n        const pieces_par_epaisseur = group.pieces\n          .reduce((h, p) => ({...h, [p.epaisseur]: [...(h[p.epaisseur]||[]), p]}), {})\n        const stats_epaisseur = Object.keys(pieces_par_epaisseur)\n          .map((epaisseur) => ({\n            epaisseur: epaisseur,\n            nb_pieces: pieces_par_epaisseur[epaisseur].length,\n            surface: pieces_par_epaisseur[epaisseur].reduce((s,p) => s + p.surface(), 0)\n          }))\n        const {xmin, xmax, ymin, ymax, zmin, zmax} = group.bounding_box()\n        const panneaux = group.pieces\n          .filter(p => p.features.includes('panneau') || p.features.includes('panneau-seul'))\n        //console.log(group.name, JSON.stringify(group.pieces.map(p => p.features)))\n        return {\n          name:        group.name,\n          dimension_x: xmax - xmin,\n          dimension_y: ymax - ymin,\n          dimension_z: zmax - zmin,\n          nb_tenons:   group.pieces.reduce((n, p) => n + p.nombre_tenons, 0),\n          nb_pieces:   group.pieces.length,\n          surface:     group.surface(),\n          epaisseurs:  stats_epaisseur,\n          nb_panneaux: panneaux.length,\n          m2_panneaux: panneaux.reduce((s,p) => s + p.surface(), 0),\n        }\n      })\n      .filter(stat => stat.nb_pieces > 0)\n  }\n\n</script>\n\n<style>\n  input[size='5'] {\n    width: 6em;\n  }\n  input[size='3'] {\n    width: 4em;\n  }\n</style>\n\n<table class=\"large styled\">\n  <caption>Statistiques pour {pieces.name} (afficher <label style=\"display: inline\"><input bind:checked={totaux} type=checkbox /> totaux</label>, <label style=\"display: inline\"><input bind:checked={par_epaiss} type=checkbox /> par épaisseur</label>, <label style=\"display: inline\"><input bind:checked={par_type} type=checkbox /> par type</label>)</caption>\n  <tr>\n    <th rowspan={(par_epaiss||par_type) ? 2 : 1}>Ensemble</th>\n    <th rowspan={(par_epaiss||par_type) ? 2 : 1}>Dimensions</th>\n    <th rowspan={(par_epaiss||par_type) ? 2 : 1}>Nombre de pièces</th>\n    <th rowspan={(par_epaiss||par_type) ? 2 : 1}>Nombre de tenons</th>\n    <th rowspan={(par_epaiss||par_type) ? 2 : 1}>Surface des pièces</th>\n    {#if par_epaiss}\n      {#each statistics_epaisseurs as ep}\n        <th colspan=2>Pièces ép={ep}</th>\n      {/each}\n    {/if}\n    {#if par_type}\n      <th colspan=2>Panneaux</th>\n    {/if}\n  </tr>\n  {#if par_epaiss || par_type}\n  <tr>\n    {#if par_epaiss}\n      {#each statistics_epaisseurs as ep}\n        <th>Nbre</th>\n        <th>m²</th>\n      {/each}\n    {/if}\n    {#if par_type}\n      <th>Nbre</th>\n      <th>m²</th>\n    {/if}\n  </tr>\n  {/if}\n  {#each statistics as stat}\n    <tr>\n      <td>{stat.name}</td>\n      <td>{stat.dimension_x} x {stat.dimension_y} x {stat.dimension_z}</td>\n      <td>{stat.nb_pieces}</td>\n      <td>{stat.nb_tenons}</td>\n      <td>{stat.surface.toFixed(6)}</td>\n      {#if par_epaiss}\n      {#each statistics_epaisseurs as ep}\n        <td>{(stat.epaisseurs.find(e => e.epaisseur == ep)||{}).nb_pieces || 0}</td>\n        <td>{((stat.epaisseurs.find(e => e.epaisseur == ep)||{}).surface || 0).toFixed(6)}</td>\n      {/each}\n      {/if}\n      {#if par_type}\n        <td>{stat.nb_panneaux}</td>\n        <td>{stat.m2_panneaux.toFixed(6)}</td>\n      {/if}\n    </tr>\n  {/each}\n</table>\n\n<hr/>\n\n<table class=\"large styled\">\n  <caption>Liste de débit</caption>\n  <tr>\n    <th>Pièce (<label style=\"display: inline\"><input bind:checked={separer} type=checkbox /> séparer</label>)</th>\n    <th>Qué</th>\n    <th>L x l x e</th>\n    <th>Arrasement</th>\n    <th>Surface (m²)</th>\n    <th>epaisseur plateau (mm)</th>\n    <th>Cubage<br/>(x<input type=number bind:value={cubemargin} size=3 min=100 step=5/>%)</th>\n    <th>Prix au m³<br/><input type=number bind:value={cubeprice} size=5 step=10/></th>\n  </tr>\n  {#each pieces3 as piece}\n  <tr>\n    <td>\n      {#if separer}\n        {#each piece.name_list as name, i}\n          {#if i != 0}<br/>{/if}\n          {name}\n        {/each}\n      {:else}\n        {piece.name}\n      {/if}\n    </td>\n    <td>{piece.que || 1}</td>\n    <td>{piece.string_dimentions()}</td>\n    <td>{piece.string_arrasement()}</td>\n    <td>{piece.largeur * piece.longueur / 1e6}</td>\n    <td>{piece.epaisseur_plateau}</td>\n    <td>{piece.que * piece.cubage(cubemargin/100).toFixed(9)}</td>\n    <td>{piece.que * piece.prix(cubeprice, cubemargin/100).toFixed(2)}</td>\n  </tr>\n  {/each}\n  <tr>\n    <td>Total</td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n    <td>{total_cube.toFixed(9)}</td>\n    <td>{total_prix.toFixed(2)}</td>\n  </tr>\n</table>\n\n<hr/>\n\n<Estimation pieces={pieces} bind:estimations={estimations} />\n\n",
    "<script>\n  import { getContext } from 'svelte';\n  import { get } from 'svelte/store';\n  import { cleanObject, reduceToObject } from './utils.js';\n  import { routeDeclare } from './route.js';\n  import InputNumber from './controls/InputNumber.svelte';\n  import InputDurationMin from './controls/InputDurationMin.svelte';\n  import InputCheckbox from './controls/InputCheckbox.svelte';\n\n  export let settings;\n  export let settings_opened = false\n\n  let componentNames = Object.keys(getContext('App-components'))\n\n  let def = {\n    cubeprice: 1440,\n    cubemargin: 135,\n    postes_estimations: [],\n  }\n\n  let ui = {}\n  settings.subscribe(settings => {\n    ui = settings\n  })\n\n  $: ui = {\n    postes_estimations: [],\n    ...ui\n  }\n\n  let merged = {}\n  $: merged = {\n    ...def,\n    ...cleanObject(ui),\n  }\n  $: settings.set(merged)\n\n  let root_element;\n  routeDeclare((route) => {\n    settings_opened = route.settings\n    return route.settings ? [root_element] : []\n  })\n\n  function addEstim(){\n    let estimName = prompt(\"Quel nom donner à l'estimation :\")\n    if(estimName) ui.postes_estimations = [...ui.postes_estimations, {\n      name: estimName,\n      value: 0,\n      indice: 'constant',\n      components: componentNames.reduce((h,c) => (h[c]=true, h), {}),\n    }]\n    console.log(ui.postes_estimations)\n  }\n\n  function removeEstim(idx){\n    ui.postes_estimations.splice(idx, 1)\n    ui.postes_estimations = ui.postes_estimations\n  }\n\n  function renameEstim(idx){\n    let poste = ui.postes_estimations[idx]\n    let newName = prompt(`Renommer la phase \"${poste.name}\" en :`, poste.name)\n    if(!newName) return;\n    ui.postes_estimations[idx].name = newName\n  }\n\n  function availableComp(ui, idx) {\n    return componentNames.filter(c => ui.postes_estimations[idx].components[c])\n  }\n\n  function open(){\n    let input = document.createElement('input');\n    input.style.display = 'none';\n    input.setAttribute('type', 'file')\n    input.addEventListener('change', (e) => {\n      let file = e.target.files[0];\n      if (!file) return\n\n      let reader = new FileReader();\n      reader.onload = (e) => {\n        let data = JSON.parse(e.target.result)\n        if(data.settings) settings.set(data.settings)\n      }\n      reader.readAsText(file);\n    }, false)\n\n    document.body.appendChild(input);\n    input.click();\n    document.body.removeChild(input);\n  }\n</script>\n\n<style>\n  .estim label {\n    display: inline\n  }\n</style>\n\n<div class=\"routable\" bind:this={root_element}>\n  <button on:click={(e) => window.location.hash = '#/'}>Fermer</button>\n  <hr/>\n\n  <label><span>Prix du bois : </span><InputNumber bind:value={ui.cubeprice} def={def.cubeprice} min=0/> €</label>\n  <label><span>Marge de cubage : </span><InputNumber bind:value={ui.cubemargin} def={def.cubemargin} min=0/> %</label>\n\n  <h2>Postes</h2>\n  <table class=\"estim\">\n    <tr>\n      <th>Nom</th>\n      <th>Temps (min)</th>\n      <th>Indice</th>\n      <th>&nbsp;</th>\n      {#each componentNames as comp}\n        <th>{comp}</th>\n      {/each}\n    </tr>\n    {#each merged.postes_estimations as estim, idx}\n      <tr>\n        <td>{estim.name} :</td>\n        <td><InputDurationMin bind:value={ui.postes_estimations[idx].value} /></td>\n        <td>\n          <select bind:value={ui.postes_estimations[idx].indice}>\n            <option value=\"\">(désactivé)</option>\n            <optgroup label=\"par opération...\">\n              <option value=\"constant\">une fois pour toutes</option>\n              <option value=\"per_component\">par élément ({availableComp(ui, idx).join(', ')})</option>\n              <option value=\"per_ferrage_charniere\">par ferrage de charnières</option>\n              <option value=\"tenon\">par tenon</option>\n            </optgroup>\n            <optgroup label=\"par type de pièce...\">\n              <option value=\"m2_trav_mont_cp\">par m² de montants ou traverses à contre-profil</option>\n              <option value=\"m2_trav_mont_ncp\">par m² de montants ou traverses (sauf contre-profil)</option>\n              <option value=\"m2_trav_mont\">par m² de montants ou traverses (tous)</option>\n              <option value=\"m2_panneau\">par m² de panneaux montés en rainure</option>\n              <option value=\"m2_panneau_seul\">par m² de panneaux libres</option>\n              <option value=\"m2_panneau_tous\">par m² de panneaux (tous)</option>\n              <option value=\"m2_cote\">par m² de côtés de tiroir</option>\n              <option value=\"m2_plateau\">par m² (toutes pièces)</option>\n              <option value=\"nb_trav_mont_cp\">par nombre de montants ou traverses à contre-profil</option>\n              <option value=\"nb_trav_mont_ncp\">par nombre de montants ou traverses (sauf contre-profil)</option>\n              <option value=\"nb_trav_mont\">par nombre de montants ou traverses (tous)</option>\n              <option value=\"nb_panneau\">par nombre de panneaux montés en rainure</option>\n              <option value=\"nb_panneau_seul\">par nombre de panneaux libres</option>\n              <option value=\"nb_panneau_tous\">par nombre de panneaux (tous)</option>\n              <option value=\"nb_cote\">par nombre de côtés de tiroir</option>\n              <option value=\"nb_plateau\">par nombre total de pièces</option>\n            </optgroup>\n            <optgroup label=\"par épaisseur...\">\n              <option value=\"m2_ep0_20\">par m² de panneau (ep ⩽ 20)</option>\n              <option value=\"m2_ep20_plus\">par m² de pièces (ep &gt; 20)</option>\n              <option value=\"nb_ep0_20\">par panneau (ep ⩽ 20)</option>\n              <option value=\"nb_ep20_plus\">par nombre de pièces (ep &gt; 20)</option>\n            </optgroup>\n          </select>\n        </td>\n        <td>\n          <button on:click={e => removeEstim(idx)}>🗑</button>\n          <button on:click={e => renameEstim(idx)}>✎</button>\n        </td>\n        {#each componentNames as comp}\n          <td>\n            <label>\n              <InputCheckbox bind:checked={ui.postes_estimations[idx].components[comp]} title={comp}/>\n              {comp.substr(0,2)}\n            </label>\n          </td>\n        {/each}\n      </tr>\n    {/each}\n    <li><button on:click={e => addEstim()}>Ajouter un poste</button></li>\n  </table>\n\n  <hr/>\n  <button on:click={(e) => window.location.hash = '#/'}>Fermer</button>\n  <button on:click={open}>Ouvrir...</button>\n  <details>\n    <summary>Contenu des préférences</summary>\n    <pre>{JSON.stringify(merged, null, 2)}</pre>\n  </details>\n</div>\n",
    "<script>\n  import { routeInfo } from './route.js';\n\n  export let data = {};\n  export let path = '0';\n\n  let selected = false\n\n  function onHashChange(){\n    const route = routeInfo(window.location.hash)\n    selected = (route.component_selector === `#component-${path}`)\n  }\n\n  window.addEventListener(\"hashchange\", onHashChange, false);\n  window.addEventListener(\"load\", onHashChange, false);\n</script>\n\n<style>\n  .selected {\n    font-weight: bold;\n  }\n</style>\n\n<a href=\"#/component/{path}\" class:selected={selected}>{data.type} {data.name}</a>\n{#if data.children}\n<ul>\n  {#each data.children as child}\n  {#if child.type}\n  <li>\n    <svelte:self path=\"{path}-{child.id}\" data={child} />\n  </li>\n  {/if}\n  {/each}\n</ul>\n{/if}\n",
    "<script>\n\n  export let value = null\n  export let def = null\n  export let force = false\n  export let init = null\n\n  if(init != null && value == null) value = init\n\n  let defname = def\n  let select\n  let default_value_id =  Math.random().toString(36).substring(2) +\n                          Math.random().toString(36).substring(2) +\n                          Math.random().toString(36).substring(2)\n\n  let inner_val = (def != null && value == null) ? default_value_id : value\n  $: value = (def != null && inner_val == default_value_id) ? null : inner_val\n\n  $: findDefName(select)\n  function findDefName(select){\n    if(!select) return\n    let option = Array.from(select.options).find(op => op.value == def)\n    if(option) defname = option.textContent\n  }\n\n  $: error = force && value != null && value != def\n\n</script>\n<style>\n  select.error {\n    box-shadow: 0 0 1.5px 1px red;\n  }\n</style>\n\n<select bind:value={inner_val} bind:this={select} class:error={error}>\n  {#if def != null}\n  <option value=\"{default_value_id}\">{defname} (par défaut)</option>\n  {/if}\n  <slot></slot>\n</select>\n",
    "<script>\n  import { cleanObject, pipeline, nextId } from '../utils.js';\n  import Component from '../Component.svelte';\n  import ChildrenPositions from '../ChildrenPositions.svelte';\n  import Piece from '../pieces/piece.js';\n  import Group from '../pieces/Group.js';\n  import SVGDrawing from '../pieces/SVGDrawing.svelte';\n  import ListeDebit from '../ListeDebit.svelte'\n  import InputCheckbox from '../controls/InputCheckbox.svelte';\n  import InputNumber from '../controls/InputNumber.svelte';\n  import InputSelect from '../controls/InputSelect.svelte';\n\n  export let path\n  export let initdata = {}\n\n  let data = {...initdata}\n\n  //\n  // Defaults\n  //\n\n  let defaults = {\n    type:  'contre-profil',\n    largeur: 400,\n    hauteur: 600,\n    profondeur: 300,\n    epaisseur_montants: 24,\n    epaisseur_traverses: 24,\n    largeur_montants: 50,\n    largeur_traverses: 50,\n    profondeur_tenons_cotes: 30,\n    profondeur_tenons: 20,\n    profondeur_rainure: 10,\n    jeu_rainure: 1,\n    epaisseur_panneau: 16,\n    panneau_dessus: true,\n    panneau_dessous: true,\n    montants_inter_longueur_tenon: 20,\n    montants: [\n      {\n      },\n      {\n      },\n    ],\n    colonnes: [\n      {\n        porte: {},\n        casiers: [\n          {\n            tiroir: false,\n            panneau_dessous: true,\n            panneau_dos: true,\n          },\n        ],\n      },\n    ],\n    ...initdata.defaults\n  }\n\n  //\n  // Internal state (recomputed)\n  //\n\n  let state = {}\n\n  let childrenState = []\n\n  //\n  // Option (internal state, saved)\n  //\n\n  let opt = { ...defaults, ...initdata.opt }\n\n  // Migrate\n  if (opt.profondeur_tenons_intermediaire) {\n    opt.profondeur_tenons_cotes = opt.profondeur_tenons\n    opt.profondeur_tenons = opt.profondeur_tenons_intermediaire\n    delete opt.profondeur_tenons_intermediaire\n  }\n  if (opt.hauteur_traverses) {\n    opt.largeur_traverses = opt.hauteur_traverse\n    delete opt.hauteur_traverses\n  }\n\n  //\n  // UI (visible state)\n  //\n\n  let ui  = {\n    ...(initdata.ui || initdata.opt),\n  }\n\n  let num_colonnes = Math.max(opt.colonnes.length, 1)\n\n  let largeur_colonnes = opt.colonnes.map(c => (c.largeur_definie ? c.largeur : null))\n  $: largeur_colonnes = Array.from(Array(num_colonnes).keys())\n    .map(i => largeur_colonnes[i] || null)\n\n  let num_casiers_colonnes = opt.colonnes.map(c => (c.casiers || [{}]).length)\n  $: num_casiers_colonnes = Array.from(Array(num_colonnes).keys())\n    .map(i => num_casiers_colonnes[i] || 1)\n\n  let hauteur_casiers_colonnes = opt.colonnes.map(c => (c.casiers || []).map(cas => cas.hauteur_definie ? cas.hauteur : null))\n  $: hauteur_casiers_colonnes = Array.from(Array(num_colonnes).keys())\n    .map(i => (hauteur_casiers_colonnes[i] || []).slice(0, num_casiers_colonnes[i]))\n\n  let ui_colonnes = opt.colonnes\n  $: ui_colonnes = Array.from(Array(num_colonnes).keys())\n    .map(i => (ui_colonnes[i] || {}))\n    .map((colonne, i) => {\n      return {\n        ...colonne,\n        porte: {\n          ...colonne.porte,\n        },\n        casiers: Array.from(Array(num_casiers_colonnes[i]).keys())\n          .map(j => ({\n            porte: {},\n            ...(colonne.casiers || [])[j],\n          }))\n      }\n    })\n\n  let ui_montants = opt.montants\n  $: ui_montants = pipeline(\n      ui_montants.slice(0, ui_montants.length - 1),\n      m => Array(num_colonnes).fill(1).map((_, i) => m[i] || {panneaux_actifs:[]}),\n      m => m.concat([ui_montants[ui_montants.length-1]]))\n    .map(montant => ({...montant, panneaux_actifs: [...(montant.panneaux_actifs||[])]}))\n\n  let selection_casier_input = '0,0'\n  $: [selection_casier_i, selection_casier_j] = selection_casier_input.split(',').map(n => parseInt(n))\n  $: selection_casier = { i: selection_casier_i, j: selection_casier_j, key: selection_casier_input}\n\n  //\n  // Update opt from ui\n  //\n\n  $: opt = pipeline(\n    {\n      ...defaults,\n      ...cleanObject({\n        ...ui,\n      }),\n    },\n    opt => updateSubdivisions(num_colonnes, opt),\n    opt => calculLargeurColonnes(largeur_colonnes, opt),\n    opt => calculColonnesCasiers(num_casiers_colonnes, hauteur_casiers_colonnes, ui_colonnes, opt),\n    opt => calculSubdivisionMontants(opt, ui_montants))\n\n  //\n  // Update children then data from opt\n  //\n\n  let childrenPos = {}\n  let children = data.children\n  $: children = calculEnfants(opt, children)\n\n  /*\n  $: console.log('Caisson.initdata = ', initdata)\n  $: console.log('Caisson.opt = ', opt)\n  $: console.log('Caisson.ui = ', ui)\n  $: console.log('Caisson.children = ', children)\n  $: console.log('Caisson.childrenPos = ', childrenPos)\n  $: console.log('Caisson.state = ', state)\n  */\n\n  $: data = {\n    ...initdata,\n    opt,\n    ui,\n    children,\n    childrenPos,\n  }\n\n  //\n  // Fonctions de calcul\n  //\n\n  function updateSubdivisions(num_colonnes, opt){\n    let opt2 = {...opt}\n    opt2.colonnes            = opt.colonnes.slice(0, num_colonnes)\n    opt2.montants            = pipeline(\n      opt.montants.slice(0, opt.montants.length-1),\n      m => Array(num_colonnes).fill(1).map((_, i) => m[i]),\n      m => m.concat([opt.montants[opt.montants.length-1]]))\n\n    for(let i = 0; i<=num_colonnes; i++) {\n      opt2.montants[i] = {\n        ...opt2.montants[i],\n      }\n      if (i >= num_colonnes) break;\n\n      opt2.colonnes[i] = {\n        largeur: null,\n        num_casiers: 1,\n        casiers: [\n          {\n            tiroir: false,\n            panneau_dessous: true,\n            panneau_dos: true,\n          }\n        ],\n        porte: {},\n        ...opt2.colonnes[i],\n      }\n    }\n    return opt2\n  }\n\n\n  function calculLargeurColonnes(largeurs, opt){\n    let cols = opt.colonnes.length\n    let espace_a_repartir = opt.largeur - (cols+1) * opt.epaisseur_montants\n    let largeurs_definies = largeurs.filter(x => (x && x != 0))\n    let cols_a_calculer = largeurs.length - largeurs_definies.length\n    let espace_reparti = largeurs_definies.reduce((a,b) => (a+b), 0)\n    let espace_restant = espace_a_repartir - espace_reparti\n    let espace_par_col = Math.floor(espace_restant / cols_a_calculer)\n    let colonnes = [...opt.colonnes]\n\n    for(let i = 0; i < cols; i++) {\n      if(largeurs[i] && largeurs[i] != 0) {\n        colonnes[i].largeur_definie = true\n        colonnes[i].largeur = largeurs[i]\n      } else if(cols_a_calculer == 1) {\n        colonnes[i].largeur_definie = false\n        colonnes[i].largeur = espace_restant\n        cols_a_calculer = 0\n        espace_restant = 0\n      } else {\n        colonnes[i].largeur_definie = false\n        colonnes[i].largeur = espace_par_col\n        espace_restant -= espace_par_col\n        cols_a_calculer -= 1\n      }\n    }\n\n    return {\n      ...opt,\n      colonnes: colonnes,\n    }\n  }\n\n  function calculColonnesCasiers(num_casiers_colonnes, hauteur_casiers_colonnes, ui_colonnes, opt){\n    let cols = opt.colonnes.length\n    let colonnes = []\n\n    for(let i = 0; i < cols; i++) {\n      let num = num_casiers_colonnes[i]\n      let ui_colonne = ui_colonnes[i]\n      let xpos = opt.epaisseur_montants * (i+1)\n        + opt.colonnes.slice(0, i).reduce((n, c) => n + c.largeur, 0)\n      colonnes[i] = pipeline(\n        opt.colonnes[i] || {},\n        col => ({\n          ...col,\n          xpos: xpos,\n          porte: {\n            ...col.porte,\n            ...ui_colonne.porte,\n          },\n        }),\n        col => {col.casiers = (col.casiers || []).slice(0, num); return col},\n        col => calculCasiers(i, col, hauteur_casiers_colonnes[i], num, ui_colonne),\n        col => ({...col, casiers: calculPositionCasiers(col.casiers, xpos)}))\n    }\n\n    return {\n      ...opt,\n      colonnes: colonnes,\n    }\n  }\n\n  function calculCasiers(i, colonne, hauteurs, num, ui_colonne){\n    let espace_a_repartir = opt.hauteur - (num+1) * opt.epaisseur_traverses\n    let hauteurs_definies = hauteurs.filter(x => (x && x != 0))\n    let casiers_a_calculer = num - hauteurs_definies.length\n    let espace_reparti = hauteurs_definies.reduce((a,b) => (a+b), 0)\n    let espace_restant = espace_a_repartir - espace_reparti\n    let espace_par_casier = Math.floor(espace_restant / casiers_a_calculer)\n\n    for(let j = 0; j < num; j++) {\n      let ui_casier = ui_colonne.casiers[j]\n      //console.log(`fusion casier ${i+1},${j+1}`, colonne.casiers[j], ui_casier)\n      let casier = {\n        hauteur: null,\n        panneau_dessous: true,\n        panneau_dos: true,\n        tiroir: false,\n        num_etageres: 0,\n        ...colonne.casiers[j],\n        ...cleanObject(ui_casier),\n        porte: {\n          double: false,\n          facade: false,\n          type: \"\",\n          ...(colonne.casiers[j] || {}).porte,\n          ...cleanObject(ui_casier.porte || {}),\n        },\n      }\n      //console.log(`fusion casier ${i+1},${j+1} = `, casier)\n      if(hauteurs[j] && hauteurs[j] != 0) {\n        casier.hauteur_definie = true\n        casier.hauteur = hauteurs[j]\n      } else if(casiers_a_calculer == 1) {\n        casier.hauteur_definie = false\n        casier.hauteur = espace_restant\n        casiers_a_calculer = 0\n        espace_restant = 0\n      } else {\n        casier.hauteur_definie = false\n        casier.hauteur = espace_par_casier\n        espace_restant -= espace_par_casier\n        casiers_a_calculer -= 1\n      }\n      colonne.casiers[j] = casier\n    }\n\n    return colonne\n  }\n\n  function calculPositionCasiers(casiers, xpos){\n    for(let j = 0; j < casiers.length; j++) {\n      const jj = casiers.length - j - 1\n      casiers[j].xpos = xpos\n      casiers[j].ypos = opt.epaisseur_traverses * (jj + 1)\n        + casiers.slice(j+1).reduce((n,c) => n + c.hauteur, 0)\n    }\n    return casiers\n  }\n\n  function calculSubdivisionMontants(opt, ui_montants){\n    let subdivisions_montants = Array.from(Array(opt.colonnes.length + 1).keys()).map((i) => {\n      let ui_montant_panneaux_actifs = ((ui_montants[i] || {}).panneaux_actifs || [])\n      let ui_montant = {\n        ...ui_montants[i],\n        panneaux_actifs: [...((ui_montants[i] || {}).panneaux_actifs || [])]\n      }\n      let casiers_g = (opt.colonnes[i-1] || {}).casiers || []\n      let casiers_d = (opt.colonnes[i]   || {}).casiers || []\n      let hauteurs_g = casiers_g.slice(0, -1).map((casier, j) => (\n        {\n          gauche: [j, j+1],\n          [0]: casier.ypos - (casier.tiroir ? 0 : opt.epaisseur_traverses),\n          'h': casier.tiroir ? opt.largeur_traverses : opt.epaisseur_traverses,\n        }))\n      let hauteurs_d = casiers_d.slice(0, -1).map((casier, j) => (\n        {\n          droite: [j, j+1],\n          [0]: casier.ypos - (casier.tiroir ? 0 : opt.epaisseur_traverses),\n          'h': casier.tiroir ? opt.largeur_traverses : opt.epaisseur_traverses,\n        }))\n      let hauteurs = hauteurs_g.concat(hauteurs_d)\n        .sort((a,b) => (a[0] < b[0]) ? -1 : (a[0] > b[0]) ? 1 : 0)\n        .map(h => ({...h, [1]: h[0] + h.h}))\n      //console.log(`opt.montants[${i}] opt.colonnes[${i-1}] =`, opt.colonnes[i-1])\n      //console.log(`opt.montants[${i}] opt.colonnes[${i}] =`, opt.colonnes[i])\n      //console.log(`opt.montants[${i}] hauteurs_g =`, hauteurs_g)\n      //console.log(`opt.montants[${i}] hauteurs_g =`, hauteurs_g.map(h => h[0]))\n      //console.log(`opt.montants[${i}] hauteurs_d =`, hauteurs_d)\n      //console.log(`opt.montants[${i}] hauteurs_d =`, hauteurs_d.map(h => h[0]))\n      //console.log(`opt.montants[${i}] hauteurs =`, hauteurs)\n      let traverses = hauteurs\n        .reduce((hh, h1) => {\n          if (hh.length == 0) return [{\n            gauche: [0, 0],\n            droite: [0, 0],\n            ...h1\n          }]\n          let h0 = hh[hh.length-1]\n          if (h1[1] - h0[0] <= opt.largeur_traverses) {\n            hh[hh.length-1] = {\n              ...h0,\n              ...h1,\n              [1]: h1[1],\n            }\n            return hh\n          }\n          return hh.concat([{\n            gauche: [h0.gauche[1], h0.gauche[1]],\n            droite: [h0.droite[1], h0.droite[1]],\n            ...h1}\n          ])\n        }, [])\n        .map(h => ({\n          ...h,\n          y1: h[0] + (h[1] - h[0]) / 2 - opt.largeur_traverses / 2,\n          y2: h[0] + (h[1] - h[0]) / 2 + opt.largeur_traverses / 2,\n        }))\n      //console.log(`opt.montants[${i}].traverses =`, traverses)\n      let ui_panneaux_actifs = Array.from(Array(traverses.length + 1).keys())\n        .map(j => typeof(ui_montant.panneaux_actifs[j]) == 'boolean' ? ui_montant.panneaux_actifs[j] : null)\n        .reduce((arr, x) => arr.concat([\n          typeof(x) == 'boolean' ? x :\n          arr.length == 0        ? true : arr[arr.length-1]]), [])\n      let panneaux = Array.from(Array(traverses.length + 1).keys()).map(j => {\n        let first = (j == 0)\n        let last  = (j >= traverses.length)\n        let cote  = (i == 0 || i == opt.colonnes.length)\n\n        return {\n          first:  first,\n          last:   last,\n          cote:   cote,\n          y1:     first ? (opt.largeur_traverses + (cote ? 0 : opt.epaisseur_traverses))\n                        : traverses[j-1].y2,\n          y2:     last  ? (opt.hauteur - opt.largeur_traverses - (cote ? 0 : opt.epaisseur_traverses))\n                        : traverses[j].y1,\n          gauche: first ? 0 : traverses[j-1].gauche[1],\n          droite: first ? 0 : traverses[j-1].droite[1],\n          actif:  ui_panneaux_actifs[j],\n        }\n      })\n      return {\n        traverses: traverses,\n        panneaux: panneaux,\n      }\n    })\n\n    return {\n      ...opt,\n      montants : opt.montants.map((m, i) => (\n        {\n          ...m,\n          ...subdivisions_montants[i],\n        }\n      ))\n    }\n  }\n\n  function calculEnfants(opt, children){\n    //console.log(`Caisson(${path}) Recalcul des enfants %o`, opt)\n    children = [...(children || [])]\n\n    // Migrate old portes\n    for(let i = 0; i < children.length; i++){\n      if(!children[i].source) children[i].source = ['Porte', 'colonne', i]\n    }\n\n    // Create new, remove old\n    for(let i = 0; i < opt.colonnes.length; i++){\n      const colonne = opt.colonnes[i]\n      children = creePorteColonne(colonne, i, children)\n\n      for(let j = 0; j < colonne.casiers.length; j++) {\n        const casier = colonne.casiers[j]\n        children = creePorteCasier(colonne, i, casier, j, children)\n        children = creeTiroirCasier(colonne, i, casier, j, children)\n        children = supprimeEtageres(colonne, i, casier, j, children)\n        children = creeEtageres(colonne, i, casier, j, children)\n      }\n    }\n\n    // Update values\n    for(let i = 0; i < children.length; i++){\n      let child = {\n        name: `n°${i+1}`,\n        ...children[i],\n      }\n\n      child = configurePorteColonne(child) || child\n      child = configurePorteFacadeCasier(child) || child\n      child = configureTiroir(child, children) || child\n      child = configureEtagere(child) || child\n\n      children[i] = child\n    }\n\n    return children\n\n    function creePorteColonne(colonne, i, children){\n      const child_idx = children.findIndex(c => c.source.join('-') == `Porte-colonne-${i}`)\n      if (!colonne.porte.type) {\n        // Pas de porte\n        if (child_idx != -1) {\n          if (confirm(`Caisson ${data.name}\\nSupprimer la porte ${children[child_idx].name} ?`)) {\n            children.splice(child_idx, 1)\n          } else {\n            children[child_idx].source.push('disabled')\n          }\n        }\n        return children\n      }\n      if (child_idx != -1) return children; // Porte trouvée\n\n      children = [...children, {\n        source: ['Porte', 'colonne', i],\n        name:   prompt(\"Quel nom donner à la porte ?\", `colonne n°${i+1}`),\n        type:   'Porte',\n        id:     nextId(children),\n      }]\n\n      return children\n    }\n\n    function configurePorteColonne(child) {\n      let source = [...child.source]\n      let [i] = source.splice(2, 1)\n      if(source.join('-') != 'Porte-colonne') return child\n\n      const col = opt.colonnes[i];\n      if(!col) return child;\n\n      const total    = (col.porte.type == 'total')\n      const demi     = (col.porte.type == 'demi')\n      const encastre = (col.porte.type == 'encastre')\n\n      const epaisseur_porte = (child.opt || {}).epaisseur || (child.opt || {}).epaisseur_montants\n\n      return {\n        ...child,\n        type: 'Porte',\n        defaults: {\n          force_largeur: true,\n          force_hauteur: true,\n          encastree: encastre,\n          largeur:\n            total    ? col.largeur + 2 * opt.epaisseur_montants :\n            demi     ? col.largeur + opt.epaisseur_montants :\n            encastre ? col.largeur\n                                           : 0,\n          hauteur:\n            total    ? opt.hauteur :\n            demi     ? opt.hauteur - opt.epaisseur_traverses :\n            encastre ? opt.hauteur - 2 * opt.epaisseur_traverses\n                                           : 0,\n        },\n        defaultPosition: {\n          x: col.ypos\n             - (total ? opt.epaisseur_montants :\n                demi  ? opt.epaisseur_montants / 2\n                                            : 0),\n          y: opt.epaisseur_traverses\n             - (total ? opt.epaisseur_traverses :\n                demi  ? opt.epaisseur_traverses / 2\n                                            : 0),\n          z: opt.profondeur\n             - (encastre ? epaisseur_porte : 0),\n        },\n      }\n    }\n\n    function typePorte(casier){\n      return casier.porte.facade ? 'Facade' : 'Porte'\n    }\n\n    function supprimeEtageres(colonne, i, casier, j, children){\n      const num_etageres = casier.num_etageres\n\n      for(let idx = children.length-1; idx >= 0; idx--){\n        const child = children[idx]\n        let source = [...child.source] // Etagere-col-i-cas-j-num-n\n        let [num] = source.splice(6,1)\n        if(source.join('-') != `Etagere-col-${i}-cas-${j}-num`) continue\n        if(num < num_etageres) continue\n\n        if (confirm(`Caisson ${data.name}\\nSupprimer l'étagère ${child.name} ?`)) {\n          children.splice(i, 1)\n        } else {\n          children[i].source.push('disabled')\n        }\n      }\n      return children\n    }\n\n    function creeEtageres(colonne, i, casier, j, children){\n      const num_etageres = casier.num_etageres\n      let name = null\n\n      for(let num = 0; num < num_etageres; num++){\n        const src = `Etagere-col-${i}-cas-${j}-num-${num}`\n        const child_idx = children.findIndex(c => c.source.join('-') == src)\n        if(child_idx != -1) continue\n\n        if(name == null) {\n          name = `colonne n°${i+1}, casier n°${j+1}`\n          name = prompt(`Quel nom donner aux étagères ?`, name) || name\n        }\n\n        children = [...children, {\n          source: ['Etagere', 'col', i, 'cas', j, 'num', num],\n          name:   `${name} #${num+1}`,\n          type:   'Etagere',\n          id:     nextId(children),\n        }]\n      }\n      return children\n    }\n\n    function configureEtagere(child) {\n      let source = [...child.source]\n      let [num] = source.splice(6, 1)\n      let [j] = source.splice(4, 1)\n      let [i] = source.splice(2, 1)\n      if(source.join('-') != 'Etagere-col-cas-num') return child\n\n      const col = opt.colonnes[i]; if(!col) return child;\n      const cas = col.casiers[j];  if(!cas)  return child;\n\n      const step = cas.hauteur / (cas.num_etageres + 1)\n\n      return {\n        ...child,\n        type: 'Etagere',\n        defaults: {\n          force_largeur:    true,\n          force_profondeur: true,\n          largeur:          col.largeur,\n          profondeur:       opt.profondeur,\n        },\n        defaultPosition: {\n          x: col.xpos,\n          y: cas.ypos + (num+1) * step,\n          z: 0,\n        },\n      }\n    }\n\n    function creePorteCasier(colonne, i, casier, j, children){\n      const type = typePorte(casier)\n\n      const variants =\n        (!casier.porte.type) ? [\n          ] :\n        (casier.porte.double) ? [\n          `${type}-col-${i}-cas-${j}-g`,\n          `${type}-col-${i}-cas-${j}-d`]\n        : [\n          `${type}-col-${i}-cas-${j}`]\n\n      const all_variants = [\n        `Porte-col-${i}-cas-${j}`,\n        `Porte-col-${i}-cas-${j}-g`,\n        `Porte-col-${i}-cas-${j}-d`,\n        `Facade-col-${i}-cas-${j}`,\n        `Facade-col-${i}-cas-${j}-g`,\n        `Facade-col-${i}-cas-${j}-d`,\n      ]\n\n      // Supprimer la facade si elle n'est pas du bon type\n      for(let idx = children.length-1; idx >= 0; idx--){\n        const source = children[idx].source.join('-')\n        //console.log(source, variants, all_variants)\n        console.log(source, children[idx].name)\n        if (variants.includes(source) || !all_variants.includes(source)) break\n\n        if (confirm(`Caisson ${data.name}\\nSupprimer la ${children[idx].type}\n        ${children[idx].name} ?`)) {\n          children.splice(idx, 1)\n        } else {\n          children[idx].source.push('disabled')\n        }\n      }\n\n      // pas de porte à créer\n      if(!casier.porte.type) return children\n\n      if(casier.porte.double) {\n        const child_idx_g = children.findIndex(c => c.source.join('-') == variants[0])\n        const child_idx_d = children.findIndex(c => c.source.join('-') == variants[1])\n        let namePrefix = `colonne n°${i+1}, casier n°${j+1}`\n        if (child_idx_g == -1 && child_idx_d == -1) {\n          namePrefix = prompt(`Quel nom donner aux ${type.toLowerCase()}s ?`, namePrefix) || namePrefix\n        }\n        if (child_idx_g == -1) {\n          children = [...children, {\n            source: [type, 'col', i, 'cas', j, 'g'],\n            name:   `${namePrefix} gauche`,\n            type:   type,\n            id:     nextId(children),\n          }]\n        }\n        if (child_idx_d == -1) {\n          children = [...children, {\n            source: [type, 'col', i, 'cas', j, 'd'],\n            name:   `${namePrefix} droite`,\n            type:   type,\n            id:     nextId(children),\n          }]\n        }\n      } else {\n        const child_idx = children.findIndex(c => c.source.join('-') == variants[0])\n        if (child_idx == -1) {\n          children = [...children, {\n            source: [type, 'col', i, 'cas', j],\n            name:   prompt(`Quel nom donner à la ${type.toLowerCase()} ?`, `colonne n°${i+1}, casier n°${j+1}`),\n            type:   type,\n            id:     nextId(children),\n          }]\n        }\n      }\n\n      return children;\n    }\n\n    function configurePorteFacadeCasier(child) {\n      let source = [...child.source]\n      let [side] = source.splice(5, 1)\n      let [j]    = source.splice(4, 1)\n      let [i]    = source.splice(2, 1)\n      let [type] = source.splice(0, 1)\n      if(source.join('-') != 'col-cas') return child\n      if(type != 'Porte' && type != 'Facade') return child\n      if(side && side != 'g' && side != 'd') return child\n\n      const col = opt.colonnes[i]; if(!col) return child;\n      const cas = col.casiers[j];  if(!cas) return child;\n\n      const double   = !!side\n      const total    = (cas.porte.type == 'total')\n      const demi     = (cas.porte.type == 'demi')\n      const encastre = (cas.porte.type == 'encastre')\n\n      const epaisseur_porte = (child.opt || {}).epaisseur || (child.opt || {}).epaisseur_montants\n\n      const defaults = {\n        force_ferrage: true,\n        ferrage:       cas.tiroir ? 'aucun' : 'charnieres',\n        encastree:     encastre,\n        force_largeur: true,\n        force_hauteur: true,\n\n        largeur: (1 / (double ? 2 : 1)) * (\n          total    ? col.largeur + 2 * opt.epaisseur_montants :\n          demi     ? col.largeur + opt.epaisseur_montants :\n          encastre ? col.largeur\n                                         : 0),\n        hauteur:\n          total    ? cas.hauteur + 2 * opt.epaisseur_traverses :\n          demi     ? cas.hauteur + opt.epaisseur_traverses :\n          encastre ? cas.hauteur\n                                         : 0,\n      }\n\n      const defaultPosition = {\n          x: cas.xpos\n             + (side == 'd' ? defaults.largeur : 0)\n             - (total ? opt.epaisseur_montants :\n                demi  ? opt.epaisseur_montants / 2\n                                            : 0),\n          y: cas.ypos\n             - (total ? opt.epaisseur_traverses :\n                demi  ? opt.epaisseur_traverses / 2\n                                            : 0),\n          z: opt.profondeur\n             - (encastre ? epaisseur_porte : 0),\n        }\n\n      return {\n        ...child,\n        type: type,\n        defaults,\n        defaultPosition,\n      }\n    }\n\n    function creeTiroirCasier(colonne, i, casier, j, children){\n      const child_idx = children.findIndex(c => c.source.join('-') == `Tiroir-col-${i}-cas-${j}`)\n\n      // Supprimer le tiroir si il n'existe pas\n      // Si il existe, return\n\n      if (!casier.tiroir) {\n        // Pas de tiroir\n        if (child_idx != -1 && confirm(`Supprimer le tiroir ${children[child_idx].name} ?`)) {\n          children.splice(child_idx, 1)\n        }\n        return children\n      }\n      if (child_idx != -1) return children; // Tiroir trouvé\n\n      // Créer le tiroir si il n'est pas encore créé\n\n      children = [...children, {\n        source: ['Tiroir', 'col', i, 'cas', j],\n        name:   prompt(`Quel nom donner au tiroir ?`, `colonne n°${i+1}, casier n°${j+1}`),\n        type:   'Tiroir',\n        id:     nextId(children),\n      }]\n\n      return children\n    }\n\n    function configureTiroir(child, children) {\n      let source = [...child.source]\n      let [j] = source.splice(4, 1)\n      let [i] = source.splice(2, 1)\n      if(source.join('-') != 'Tiroir-col-cas') return child\n\n      const col = opt.colonnes[i]; if(!col) return child;\n      const cas = col.casiers[j];  if(!cas) return child;\n\n      const facade = children.find(c => c.source.join('-') == `${typePorte(cas)}-col-${i}-cas-${j}`) || {}\n      const epaisseur_porte = facade ? ((facade.opt || {}).epaisseur || (facade.opt || {}).epaisseur_montants) : 0\n      const retrait = (cas.porte.type == 'encastre') ? epaisseur_porte : 0\n\n      return {\n        ...child,\n        type: 'Tiroir',\n        defaults: {\n          force_largeur: true,\n          force_hauteur: true,\n          largeur:       col.largeur,\n          hauteur:       Math.min(150, cas.hauteur),\n          profondeur:    opt.profondeur - retrait,\n        },\n        defaultPosition: {\n          x: cas.xpos,\n          y: cas.ypos,\n          z: (cas.porte.type == 'encastre') ? epaisseur_porte : 0,\n        },\n      }\n    }\n  }\n\n  //\n  // Pièces\n  //\n\n  let montant = new Piece()\n    .add_name(\"Montant\")\n    .add_features('montant')\n\n  let traverse = new Piece()\n    .add_name(\"Traverse\")\n    .add_features('traverse')\n\n  let piece_panneau = new Piece()\n    .add_name(\"Panneau\")\n    .add_features('panneau')\n\n  $: montants_template = montant\n    .build(\n      opt.hauteur,\n      opt.largeur_montants,\n      opt.epaisseur_montants)\n\n  $: montant_ar_g = montants_template\n    .add_name(\"arrière-gauche\")\n    .put(0, 0, 0, 'yzx')\n\n  $: montant_av_g = montants_template\n    .add_name(\"avant-gauche\")\n    .put(opt.largeur - montants_template.epaisseur, 0, opt.profondeur - montants_template.largeur, 'yzx')\n\n  $: montant_ar_d = montants_template\n    .add_name(\"arrière-droit\")\n    .put(opt.largeur - montants_template.epaisseur, 0, 0, 'yzx')\n\n  $: montant_av_d = montants_template\n    .add_name(\"avant-droit\")\n    .put(0, 0, opt.profondeur - montants_template.largeur, 'yzx')\n\n  $: traverses_cote = traverse\n    .build(\n      opt.profondeur - 2 * (opt.largeur_montants - opt.profondeur_tenons_cotes),\n      opt.largeur_traverses,\n      opt.epaisseur_traverses)\n    .usine_tenons(opt.profondeur_tenons_cotes)\n    .put(null, null, opt.largeur_montants - opt.profondeur_tenons_cotes, 'zyx')\n\n  $: traverse_cote_h_g = traverses_cote\n    .add_name(\"haut-gauche\")\n    .put(0, 0)\n\n  $: traverse_cote_b_g = traverses_cote\n    .add_name(\"bas-gauche\")\n    .put(0, opt.hauteur - traverses_cote.largeur)\n\n  $: traverse_cote_h_d = traverses_cote\n    .add_name(\"haut-droit\")\n    .put(opt.largeur - traverses_cote.epaisseur, 0)\n\n  $: traverse_cote_b_d = traverses_cote\n    .add_name(\"bas-droit\")\n    .put(opt.largeur - traverses_cote.epaisseur, opt.hauteur - traverses_cote.largeur)\n\n  $: traverses = traverse\n    .add_name(\"principale\")\n    .build(\n      opt.largeur - 2 * (opt.epaisseur_montants - opt.profondeur_tenons),\n      opt.largeur_traverses,\n      opt.epaisseur_traverses)\n    .usine_tenons(opt.profondeur_tenons)\n    .put(opt.epaisseur_montants - opt.profondeur_tenons, null, null, 'xzy')\n\n  $: traverse_ar_h = traverses\n    .add_name(\"arrière-haut\")\n    .put(null, 0, 0)\n\n  $: traverse_ar_b = traverses\n    .add_name(\"arrière-bas\")\n    .put(null, opt.hauteur - traverses.epaisseur, 0)\n\n  $: traverse_av_h = traverses\n    .add_name(\"avant-haut\")\n    .put(null, 0, opt.profondeur - traverses.largeur)\n\n  $: traverse_av_b = traverses\n    .add_name(\"avant-bas\")\n    .put(null, opt.hauteur - traverses.epaisseur, opt.profondeur - traverses.largeur)\n\n  $: panneaux_haut_bas = piece_panneau\n    .build(\n      opt.largeur - 2 * (opt.epaisseur_montants - opt.profondeur_rainure + opt.jeu_rainure),\n      opt.profondeur - 2 * (opt.largeur_traverses - opt.profondeur_rainure + opt.jeu_rainure),\n      opt.epaisseur_panneau)\n    .put(\n      opt.epaisseur_montants - opt.profondeur_rainure + opt.jeu_rainure,\n      null,\n      opt.largeur_montants - opt.profondeur_rainure + opt.jeu_rainure,\n      'xzy')\n\n  $: panneau_h = !opt.panneau_dessus ? null : panneaux_haut_bas\n    .add_name(\"haut\")\n    .put(null, 0)\n\n  $: panneau_b = !opt.panneau_dessous ? null : panneaux_haut_bas\n    .add_name(\"bas\")\n    .put(null, opt.hauteur - panneaux_haut_bas.epaisseur)\n\n  $: panneaux_dos = opt.colonnes.map((col, i) => (col.casiers.map((casier, j) =>\n    (casier.panneau_dos == false) ? null :\n    (piece_panneau\n      .add_name(\"dos\", `colonne n°${i+1}`, `casier n°${j+1}`)\n      .build(\n        casier.hauteur + 2 * (opt.profondeur_rainure - opt.jeu_rainure),\n        col.largeur + opt.epaisseur_montants - opt.largeur_montants / 2\n                    + 2 * (opt.profondeur_rainure - opt.jeu_rainure),\n        opt.epaisseur_panneau)\n      .put(\n        casier.xpos - opt.profondeur_rainure + opt.jeu_rainure,\n        casier.ypos - opt.profondeur_rainure + opt.jeu_rainure,\n        0, 'yxz')))))\n\n  $: montants_cloisons = Array.from(Array(opt.colonnes.length - 1).keys()).map((i) => (montant\n    .add_name(`cloison n°${i+1}`)\n    .build(\n      opt.hauteur - 2 * (opt.epaisseur_traverses - opt.montants_inter_longueur_tenon),\n      opt.largeur_montants,\n      opt.epaisseur_montants)\n    .usine_tenons(opt.montants_inter_longueur_tenon)\n    .put(\n      opt.epaisseur_montants\n        + opt.colonnes.slice(0, i+1).map(x => x.largeur).reduce((a, b) => a+b, 0)\n        + i * opt.epaisseur_montants,\n      opt.epaisseur_traverses - opt.montants_inter_longueur_tenon,\n      null,\n      'yzx')))\n\n  $: montants_cloisons_av = montants_cloisons.map((m, i) => (m\n    .add_name(\"avant\")\n    .put(null, null, opt.profondeur - m.largeur)))\n\n  $: montants_cloisons_ar = montants_cloisons.map((m, i) => (m\n    .add_name(\"arrière\")\n    .put(null, null, 0)))\n\n  $: traverses_cote_inter_caissons =\n    opt.montants.map((sub, i) => (\n      sub.traverses.map((h, j) => (traverses_cote\n        .add_name(\n          (i == 0)                  ? \"coté gauche\" :\n          (i < opt.colonnes.length) ? `cloison n°${i}` : \"coté droit\")\n        .add_name(`traverse n°${j+1}`)\n        .put(\n          opt.epaisseur_montants * (i)\n            + opt.colonnes.slice(0, i).reduce((n, c) => n+c.largeur, 0),\n          h.y1)\n      ))\n    ))\n\n  $: panneaux_cote_et_cloisons = opt.montants.map((sub, i) => (\n    sub.panneaux.map((panneau, j) => !panneau.actif ? null : (\n      piece_panneau\n      .add_name(\n        (i == 0)                   ? \"coté gauche\" :\n        (i >= opt.colonnes.length) ? \"coté droit\"  : `cloison n°${i}`,\n        `caisson n°${j+1}`)\n      .build(\n        panneau.y2 - panneau.y1 + 2 * (opt.profondeur_rainure - opt.jeu_rainure),\n        opt.profondeur - 2 * (opt.largeur_traverses - opt.profondeur_rainure + opt.jeu_rainure),\n        opt.epaisseur_panneau)\n      .put(\n        opt.epaisseur_montants * (i)\n          + opt.colonnes.slice(0, i).reduce((n, c) => n+c.largeur, 0),\n        panneau.y1 - opt.profondeur_rainure + opt.jeu_rainure,\n        opt.largeur_montants - opt.profondeur_rainure + opt.jeu_rainure,\n        'yzx')\n    ))\n  ))\n\n  $: traverses_cloisons = Array.from(Array(opt.colonnes.length - 1).keys()).map((i) => (traverse\n    .add_name(`cloison n°${i+1}`)\n    .build(\n      opt.profondeur - 2 * (opt.largeur_montants - opt.profondeur_tenons_cotes),\n      opt.largeur_traverses,\n      opt.epaisseur_traverses)\n    .usine_tenons(opt.profondeur_tenons_cotes)\n    .put(\n      opt.epaisseur_montants\n        + opt.colonnes.slice(0, i+1).map(x => x.largeur).reduce((a, b) => a+b, 0)\n        + i * opt.epaisseur_montants,\n      null,\n      opt.largeur_montants - opt.profondeur_tenons_cotes,\n      'zyx') ))\n\n  $: traverses_cloisons_h = traverses_cloisons.map((t, i) => (t\n    .add_name(\"haut\")\n    .put(null, opt.epaisseur_traverses)))\n\n  $: traverses_cloisons_b = traverses_cloisons.map((t, i) => (t\n    .add_name(\"bas\")\n    .put(null, opt.hauteur - opt.epaisseur_traverses - t.largeur)))\n\n  $: traverses_inter2_av_ar = opt.colonnes.map((col, i) => (\n    col.casiers.map((casier, j) => (j == col.casiers.length-1) ? null : (\n      traverse\n        .add_name(\"intermédiaire\")\n        .build(col.largeur, opt.largeur_traverses, opt.epaisseur_traverses)\n        .ajout_tenons(opt.profondeur_tenons)\n        .put(\n          casier.xpos - opt.profondeur_tenons,\n          casier.ypos - opt.epaisseur_traverses,\n          null,\n          'xzy')\n    ))\n  ))\n\n  $: traverses_inter2_av = traverses_inter2_av_ar.map((col, i) => (\n    col.map((tr, j) => (tr == null) ? null : (tr\n      .add_name(\"avant\", `cloison n°${i+1}`, `caisson n°${j}`)\n      .put(null, null, opt.profondeur - opt.largeur_montants)\n    ))\n  ))\n\n  $: traverses_inter2_ar = traverses_inter2_av_ar.map((col, i) => (\n    col.map((tr, j) => (tr == null) ? null : (tr\n      .add_name(\"arrière\", `cloison n°${i+1}`, `caisson n°${j}`)\n      .put(null, null, 0)\n    ))\n  ))\n\n  $: panneau_inter2_dessous = opt.colonnes.map((col, i) => (\n    col.casiers.map((casier, j) =>\n      (j == col.casiers.length-1) ? null :\n      (casier.panneau_dessous === false) ? null :\n      (piece_panneau\n        .add_name(\"dessous\", `colonne n°${i+1}`, `casier n°${j+1}`)\n        .build(\n          col.largeur\n            + 2 * (opt.profondeur_rainure - opt.jeu_rainure),\n          opt.profondeur\n            - 2 * opt.largeur_traverses\n            + 2 * (opt.profondeur_rainure - opt.jeu_rainure),\n          opt.epaisseur_panneau)\n        .put(\n          casier.xpos - opt.profondeur_rainure + opt.jeu_rainure,\n          casier.ypos - opt.epaisseur_panneau,\n          opt.largeur_traverses\n            - opt.profondeur_rainure + opt.jeu_rainure,\n          'xzy')\n    ))\n  ))\n\n  let all_pieces = []\n  let child_pieces = []\n\n  $: pieces = [\n    montant_ar_g, montant_av_g, montant_ar_d, montant_av_d,\n    traverse_cote_b_d, traverse_cote_b_g, traverse_cote_h_d, traverse_cote_h_g,\n    traverse_av_h, traverse_av_b, traverse_ar_h, traverse_ar_b,\n    panneau_h, panneau_b,\n  ]\n    .concat(panneaux_dos.reduce((a,b) => a.concat(b), []))\n    .concat(panneaux_cote_et_cloisons.reduce((a,b) => a.concat(b), []))\n    .concat(montants_cloisons_ar)\n    .concat(montants_cloisons_av)\n    .concat(traverses_cloisons_h)\n    .concat(traverses_cloisons_b)\n    .concat(traverses_inter2_av.reduce((a,b) => a.concat(b), []))\n    .concat(traverses_inter2_ar.reduce((a,b) => a.concat(b), []))\n    .concat(traverses_cote_inter_caissons.reduce((a,b) => a.concat(b), []))\n    .concat(panneau_inter2_dessous.reduce((a,b) => a.concat(b), []))\n    .filter(x => x)\n\n  $: all_pieces = pieces.concat(child_pieces)\n\n  $: state.pieces = all_pieces\n</script>\n\n<style>\n  form > label {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    max-width: 30em;\n  }\n  form > label > *:first-child {\n    flex-grow: 1;\n  }\n  hr.clear {\n    clear: both;\n    border: none;\n  }\n  td {\n    vertical-align: top;\n  }\n  table.panneaux .center {\n    text-align: center\n  }\n  table.panneaux .vertical {\n    //transform: rotate(-90deg);\n    //transform-origin: left;\n    //text-orientation: mixed;\n    writing-mode: sideways-lr;\n    min-width: 1em;\n  }\n\n  .meuble {\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    margin: 0.5em;\n  }\n  .meuble .colonne {\n    display: flex;\n    flex-direction: column;\n    width: 2em;\n  }\n  .meuble .colonne .casier {\n    border: 1px solid #eee;\n    text-align: center;\n  }\n  .meuble .colonne .casier input[type=radio] {\n    margin: 0.5em;\n  }\n\n  .meuble .casier.panneau-haut           { border-top: 3px solid black; }\n  .meuble .casier.panneau-bas            { border-bottom: 3px solid black; }\n  .meuble .casier.panneau-gauche-partiel { border-left: 3px dotted black; }\n  .meuble .casier.panneau-droit-partiel  { border-right: 3px dotted black; }\n  .meuble .casier.panneau-gauche         { border-left: 3px solid black; }\n  .meuble .casier.panneau-droit          { border-right: 3px solid black; }\n  .meuble .casier.panneau-dos            { background-color: #ddd; }\n\n  .prefs-casier {\n    display: flex;\n    flex-direction: row;\n    align-items: flex-start;\n  }\n\n  .prefs-casier > * {\n    margin: 0.5em;\n  }\n</style>\n\n<Component bind:data={data} path={path} state={state} bind:childrenState={childrenState} bind:children={children} on:datachange>\n  <div slot=\"plan\">\n    <SVGDrawing pieces={all_pieces} name={`Caisson ${data.name}`} />\n  </div>\n\n  <div class=\"main\" slot=\"dim\">\n\n    <h3>Mesures</h3>\n\n    <form>\n    <label><span>Hauteur    : </span><InputNumber min=0 bind:value={ui.hauteur} def={defaults.hauteur} /> mm </label>\n    <label><span>Largeur    : </span><InputNumber min=0 bind:value={ui.largeur} def={defaults.largeur}/> mm</label>\n    <label><span>Profondeur : </span><InputNumber min=0 bind:value={ui.profondeur} def={defaults.profondeur}/> mm </label>\n    <label><span>Colonnes   : </span><input type=number bind:value={num_colonnes} min=1/></label>\n\n    <table>\n      <tr>\n        <td></td>\n        {#each opt.colonnes as colonne, i}\n          <th>Colonne n°{i+1}</th>\n        {/each}\n      </tr>\n      <tr>\n        <td>Largeur intérieure&nbsp;:&nbsp;</td>\n        {#each opt.colonnes as colonne, i}\n        <td>\n          <input type=number min=0\n            placeholder={colonne.largeur}\n            bind:value={largeur_colonnes[i]}\n            style=\"width: 5em\" />\n        </td>\n        {/each}\n        <td>mm</td>\n      </tr>\n      <tr>\n        <td>Casiers&nbsp;:&nbsp;</td>\n        {#each opt.colonnes as colonne, i}\n        <td>\n          <input type=number min=1\n            bind:value={num_casiers_colonnes[i]}\n            style=\"width: 5em\" />\n        </td>\n        {/each}\n        <td></td>\n      </tr>\n      <tr>\n        <td>Hauteur intérieure&nbsp;:&nbsp;</td>\n        {#each opt.colonnes as colonne, i}\n        <td>\n          {#each colonne.casiers as casier, j}\n            {#if j > 0}\n            <br/>\n            {/if}\n            <input type=number min=1\n              placeholder={colonne.casiers[j].hauteur}\n              bind:value={hauteur_casiers_colonnes[i][j]}\n              style=\"width: 5em\" />\n          {/each}\n        </td>\n        {/each}\n        <td></td>\n      </tr>\n    </table>\n\n    {#if largeur_colonnes.filter(x => (x && x != 0)).length == largeur_colonnes.length}\n    <p>Attention : trop de largeurs sont définies en même temps</p>\n    {/if}\n\n    <hr/>\n\n    <div class=\"prefs-casier\">\n      <div class=\"meuble\"\n        class:panneau-haut={opt.panneau_dessus}\n        class:panneau-bas={opt.panneau_dessous}>\n        {#each opt.colonnes as colonne, i}\n        <div class=\"colonne colonne-{i}\">\n          <!--<div>Colonne n°{i}</div>-->\n          {#each colonne.casiers as casier, j}\n          <label\n            class=\"casier casier-{i}-{j}\"\n            class:panneau-haut={  j == 0 ? opt.panneau_dessus :\n                                  opt.colonnes[i].casiers[j-1].panneau_dessous}\n            class:panneau-bas={   j < ui_colonnes[i].casiers.length-1 ?\n                                  opt.colonnes[i].casiers[j].panneau_dessous :\n                                  opt.panneau_dessous}\n            class:panneau-gauche={opt.montants[i].panneaux\n                                  .map((p,k) => p.droite != j || opt.montants[i].panneaux[k].actif)\n                                  .reduce((b, p) => b && p, true)}\n            class:panneau-droit={ opt.montants[i+1].panneaux\n                                  .map((p,k) => p.gauche != j || opt.montants[i+1].panneaux[k].actif)\n                                  .reduce((b, p) => b && p, true)}\n            class:panneau-gauche-partiel={\n                                  opt.montants[i].panneaux\n                                  .map((p,k) => p.droite == j && opt.montants[i].panneaux[k].actif)\n                                  .reduce((b, p) => b || p, false)}\n            class:panneau-droit-partiel={\n                                  opt.montants[i+1].panneaux\n                                  .map((p,k) => p.gauche == j && opt.montants[i+1].panneaux[k].actif)\n                                  .reduce((b, p) => b || p, false)}\n            class:panneau-dos={opt.colonnes[i].casiers[j].panneau_dos}\n            class:tiroir={opt.colonnes[i].casiers[j].tiroir}\n            style=\"flex-grow: {casier.hauteur}\">\n            <!-- Casier n°{j} -->\n            <input type=\"radio\" name=\"selection-casier\" value={`${i},${j}`} bind:group={selection_casier_input} />\n          </label>\n          {/each}\n        </div>\n        {/each}\n      </div>\n\n      <div>\n        {#each [selection_casier] as sel (sel.key)}\n        <p><strong>Colonne n°{selection_casier_i+1}</strong></p>\n        <fieldset>\n          <legend>Porte colonne n°{selection_casier_i+1}</legend>\n          <label>\n            <span>Type :&nbsp;</span>\n            <InputSelect init={opt.colonnes[selection_casier_i].porte.type} bind:value={ui_colonnes[selection_casier_i].porte.type}>\n              <option value=\"\">Aucune</option>\n              <option value=\"total\">Recouvrement total</option>\n              <option value=\"demi\">Recouvrement à moitié</option>\n              <option value=\"encastre\">Encastré</option>\n            </InputSelect>\n          </label>\n          <label style=\"display: none\"><InputCheckbox tristate={false}\n            def={opt.colonnes[selection_casier_i].porte.double}\n            bind:checked={ui_colonnes[selection_casier_i].porte.double}\n            /> porte double</label>\n        </fieldset>\n        {/each}\n      </div>\n\n      <div>\n        {#each [selection_casier] as sel (sel.key)}\n        <p><strong>Casier n° {selection_casier_j+1}</strong></p>\n        <fieldset>\n          <legend>Porte col°{selection_casier_i+1} cas°{selection_casier_j+1}</legend>\n          <label>\n            <span>Type :&nbsp;</span>\n            <InputSelect\n              init={opt.colonnes[selection_casier_i].casiers[selection_casier_j].porte.type}\n              bind:value={ui_colonnes[selection_casier_i].casiers[selection_casier_j].porte.type}>\n              <option value=\"\">Aucune</option>\n              <option value=\"total\">Recouvrement total</option>\n              <option value=\"demi\">Recouvrement à moitié</option>\n              <option value=\"encastre\">Encastré</option>\n            </InputSelect>\n            <label><InputCheckbox tristate={false}\n              def={opt.colonnes[selection_casier_i].casiers[selection_casier_j].porte.double}\n              bind:checked={ui_colonnes[selection_casier_i].casiers[selection_casier_j].porte.double}\n              /> porte double</label>\n            <label><InputCheckbox tristate={false}\n              def={opt.colonnes[selection_casier_i].casiers[selection_casier_j].porte.facade}\n              bind:checked={ui_colonnes[selection_casier_i].casiers[selection_casier_j].porte.facade}\n              /> façade seulement</label>\n          </label>\n        </fieldset>\n        <fieldset>\n          <legend>Étagère col°{selection_casier_i+1} cas°{selection_casier_j+1}</legend>\n          <label>\n            <span>Nombre d'étagères</span>\n            <InputNumber\n              def={opt.colonnes[selection_casier_i].casiers[selection_casier_j].num_etageres}\n              bind:value={ui_colonnes[selection_casier_i].casiers[selection_casier_j].num_etageres}\n              />\n          </label>\n        </fieldset>\n        <fieldset>\n          <legend>Tiroir col°{selection_casier_i+1} cas°{selection_casier_j+1}</legend>\n          <label><InputCheckbox tristate={false}\n            def={opt.colonnes[selection_casier_i].casiers[selection_casier_j].tiroir}\n            bind:checked={ui_colonnes[selection_casier_i].casiers[selection_casier_j].tiroir}\n            /> tiroir</label>\n        </fieldset>\n        <fieldset>\n          <legend>Panneaux col°{selection_casier_i+1} cas°{selection_casier_j+1}</legend>\n          {#if selection_casier_j == 0}\n          <label><InputCheckbox tristate={false}\n            def={opt.panneau_dessus}\n            bind:checked={ui.panneau_dessus}\n            /> panneau dessus (tout le meuble)</label>\n          {:else}\n          <label><InputCheckbox tristate={false}\n            def={opt.colonnes[selection_casier_i].casiers[selection_casier_j-1].panneau_dessous}\n            bind:checked={ui_colonnes[selection_casier_i].casiers[selection_casier_j-1].panneau_dessous}\n            /> panneau dessus</label>\n          {/if}\n          <label><InputCheckbox tristate={false}\n            def={opt.colonnes[selection_casier_i].casiers[selection_casier_j].panneau_dos}\n            bind:checked={ui_colonnes[selection_casier_i].casiers[selection_casier_j].panneau_dos}\n            /> panneau dos</label>\n          {#if selection_casier_j < ui_colonnes[selection_casier_i].casiers.length-1}\n          <label><InputCheckbox tristate={false}\n            def={opt.colonnes[selection_casier_i].casiers[selection_casier_j].panneau_dessous}\n            bind:checked={ui_colonnes[selection_casier_i].casiers[selection_casier_j].panneau_dessous}\n            /> panneau dessous</label>\n          {:else}\n          <label><InputCheckbox tristate={false}\n            def={opt.panneau_dessous}\n            bind:checked={ui.panneau_dessous}\n            /> panneau dessous (tout le meuble)</label>\n          {/if}\n          {#each opt.montants[selection_casier_i].panneaux as panneau, k}\n            {#if panneau.droite == selection_casier_j}\n              <label><InputCheckbox tristate={false}\n                def={opt.montants[selection_casier_i].panneaux[k].actif}\n                bind:checked={ui_montants[selection_casier_i].panneaux_actifs[k]}\n                /> panneau gauche (n°{k+1})</label>\n            {/if}\n          {/each}\n          {#each opt.montants[selection_casier_i+1].panneaux as panneau, k}\n            {#if panneau.gauche == selection_casier_j}\n              <label><InputCheckbox tristate={false}\n                def={opt.montants[selection_casier_i+1].panneaux[k].actif}\n                bind:checked={ui_montants[selection_casier_i+1].panneaux_actifs[k]}\n                /> panneau droite (n°{k+1})</label>\n            {/if}\n          {/each}\n        </fieldset>\n        {/each}\n      </div>\n    </div>\n\n    <hr/>\n\n    <label><span>Épaisseur montants : </span><InputNumber def={opt.epaisseur_montants} bind:value={ui.epaisseur_montants} min=0/> mm</label>\n    <label><span>Épaisseur traverses : </span><InputNumber def={opt.epaisseur_traverses} bind:value={ui.epaisseur_traverses} min=0/> mm</label>\n    <label><span>Largeur montants : </span><InputNumber def={opt.largeur_montants} bind:value={ui.largeur_montants} min=0/> mm</label>\n    <label><span>Largeur traverses : </span><InputNumber def={opt.largeur_traverses} bind:value={ui.largeur_traverses} min=0/> mm</label>\n    <label><span>Profondeur tenons cotés : </span><InputNumber def={opt.profondeur_tenons_cotes} bind:value={ui.profondeur_tenons_cotes} min=0/> mm</label>\n    <label><span>Profondeur tenons : </span><InputNumber def={opt.profondeur_tenons} bind:value={ui.profondeur_tenons} min=0/> mm</label>\n\n    <hr/>\n\n    <label><span>Épaisseur panneau : </span><InputNumber def={opt.epaisseur_panneau} bind:value={ui.epaisseur_panneau} min=0/> mm </label>\n    <label><span>Profondeur rainure : </span><InputNumber def={opt.profondeur_rainure} bind:value={ui.profondeur_rainure} min=0/> mm</label>\n    <label><span>Jeu panneau / rainure : </span><InputNumber def={opt.jeu_rainure} bind:value={ui.jeu_rainure} min=0/> mm</label>\n    <label><span>Longueur tenons cloisons : </span> <InputNumber def={opt.montants_inter_longueur_tenon} bind:value={ui.montants_inter_longueur_tenon} min=0/> mm</label>\n\n    </form>\n  </div>\n\n  <div slot=\"children\">\n    <ChildrenPositions\n      children={children}\n      childrenState={childrenState}\n      defaultChildrenPos={children.map(c => c.defaultPosition)}\n      bind:childrenPos={childrenPos}\n      bind:pieces={child_pieces} />\n  </div>\n\n  <div slot=\"tables\">\n    <ListeDebit pieces={new Group(all_pieces, `Caisson ${data.name}`, 'Caisson')} />\n  </div>\n</Component>\n",
    "<script>\n  import { onMount } from 'svelte';\n  import { cleanObject } from '../utils.js';\n  import InputNumber from '../controls/InputNumber.svelte';\n  import InputCheckbox from '../controls/InputCheckbox.svelte';\n  import Component from '../Component.svelte';\n  import Cote from '../draw/Cote.svelte';\n  import Piece from '../pieces/piece.js';\n  import Group from '../pieces/Group.js';\n  import SVGPiece from '../pieces/SVGPiece.svelte';\n  import SVGDrawing from '../pieces/SVGDrawing.svelte';\n  import ListeDebit from '../ListeDebit.svelte'\n\n  export let path\n  export let initdata = {}\n\n  let data = {...initdata}\n\n  let defaults = {\n    largeur: 400,\n    profondeur: 300,\n    epaisseur: 18,\n    ...initdata.defaults\n  }\n\n  let opt = { ...initdata.opt }\n  let ui  = { ...(initdata.ui || initdata.opt) }\n  let state = {}\n\n  $: opt      = {...defaults, ...cleanObject(ui)}\n  $: data.opt = opt\n  $: data.ui  = ui\n\n  let zoom = 0.5\n\n  $: etagere = new Piece()\n    .add_name(\"Étagère\")\n    .build(opt.largeur, opt.profondeur, opt.epaisseur)\n    .put(0, 0, 0, 'xzy')\n    .add_features('panneau-seul')\n\n  $: pieces = [etagere]\n\n  $: state.pieces = pieces\n</script>\n\n<style>\n  form > * {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    max-width: 30em;\n  }\n  form > * > *:first-child {\n    flex-grow: 1;\n  }\n  hr.clear {\n    clear: both;\n    border: none;\n  }\n  table {\n    clear: both;\n  }\n</style>\n\n<Component bind:data={data} path={path} state={state} on:datachange>\n  <div slot=\"plan\">\n    <SVGDrawing pieces={pieces} name={`Étagère ${data.name}`} />\n  </div>\n\n  <div class=\"main\" slot=\"dim\">\n    <form>\n    <label><span>Largeur    : </span><InputNumber min=0 bind:value={ui.largeur} def={defaults.largeur} force={defaults.force_largeur}/> mm</label>\n    <label><span>Profondeur : </span><InputNumber min=0 bind:value={ui.profondeur} def={defaults.profondeur} force={defaults.force_profondeur}/> mm</label>\n    <label><span>Épaisseur  : </span><InputNumber min=0 bind:value={ui.epaisseur} def={defaults.epaisseur} force={defaults.force_epaisseur}/> mm</label>\n  </div>\n\n  <div slot=\"tables\">\n    <ListeDebit pieces={new Group(pieces, `Étagère ${data.name}`, 'Etagere')} />\n  </div>\n</Component>\n",
    "<script>\n  import { onMount } from 'svelte';\n  import { cleanObject } from '../utils.js';\n  import InputNumber from '../controls/InputNumber.svelte';\n  import InputCheckbox from '../controls/InputCheckbox.svelte';\n  import Component from '../Component.svelte';\n  import Cote from '../draw/Cote.svelte';\n  import Piece from '../pieces/piece.js';\n  import Group from '../pieces/Group.js';\n  import SVGPiece from '../pieces/SVGPiece.svelte';\n  import SVGDrawing from '../pieces/SVGDrawing.svelte';\n  import ListeDebit from '../ListeDebit.svelte'\n\n  export let path\n  export let initdata = {}\n\n  let data = {...initdata}\n  let state = {}\n\n  let defaults = {\n    largeur: 400,\n    hauteur: 150,\n    epaisseur: 18,\n    ...initdata.defaults\n  }\n\n  let opt = { ...initdata.opt }\n  let ui  = { ...(initdata.ui || initdata.opt) }\n\n  $: opt      = {...defaults, ...cleanObject(ui)}\n  $: data.opt = opt\n  $: data.ui  = ui\n\n  let zoom = 0.5\n\n  $: facade = new Piece()\n    .add_name(\"Façade\")\n    .build(opt.largeur, opt.hauteur, opt.epaisseur)\n    .put(0, 0, 0, 'xyz')\n    .add_features('panneau-seul')\n\n  $: pieces = [facade]\n\n  $: state.pieces = pieces\n</script>\n\n<style>\n  form > * {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    max-width: 30em;\n  }\n  form > * > *:first-child {\n    flex-grow: 1;\n  }\n  hr.clear {\n    clear: both;\n    border: none;\n  }\n  table {\n    clear: both;\n  }\n</style>\n\n<Component bind:data={data} path={path} state={state} on:datachange>\n  <div slot=\"plan\">\n    <SVGDrawing pieces={pieces} name={`Façade ${data.name}`} />\n  </div>\n\n  <div class=\"main\" slot=\"dim\">\n    <form>\n    <label><span>Largeur    : </span><InputNumber min=0 bind:value={ui.largeur} def={defaults.largeur} force={defaults.force_largeur}/> mm</label>\n    <label><span>Hauteur    : </span><InputNumber min=0 bind:value={ui.hauteur} def={defaults.hauteur} force={defaults.force_hauteur}/> mm</label>\n    <label><span>Épaisseur  : </span><InputNumber min=0 bind:value={ui.epaisseur} def={defaults.epaisseur} force={defaults.force_epaisseur}/> mm</label>\n  </div>\n\n  <div slot=\"tables\">\n    <ListeDebit pieces={new Group(pieces, `Façade ${data.name}`, 'Facade')} />\n  </div>\n</Component>\n",
    "<script>\n  import { onMount } from 'svelte';\n  import { cleanObject, pipeline } from '../utils.js';\n  import InputNumber from '../controls/InputNumber.svelte';\n  import InputCheckbox from '../controls/InputCheckbox.svelte';\n  import InputSelect from '../controls/InputSelect.svelte';\n  import Component from '../Component.svelte';\n  import Cote from '../draw/Cote.svelte';\n  import Piece from '../pieces/piece.js';\n  import Group from '../pieces/Group.js';\n  import SVGPiece from '../pieces/SVGPiece.svelte';\n  import SVGDrawing from '../pieces/SVGDrawing.svelte';\n  import ListeDebit from '../ListeDebit.svelte'\n\n  export let path\n  export let initdata = {}\n\n  let data = {...initdata}\n\n  let defaults = {\n    quantite: 1,\n    type:  'contre-profil',\n    largeur: 400,\n    hauteur: 600,\n    epaisseur: 18,\n    largeur_montants: 70,\n    largeur_traverses: 70,\n    profondeur_tenons: 30,\n    profondeur_rainure: 10,\n    profondeur_profil: 15,\n    encastree: false,\n    jeu_encastrement: 2,\n    jeu_rainure: 1,\n    epaisseur_panneau: 15,\n    inclure_panneau: true,\n    ferrage: 'charnieres',\n    ...initdata.defaults\n  }\n\n  let opt = { ...initdata.opt }\n  let ui  = { ...(initdata.ui || initdata.opt) }\n\n  $: opt = pipeline(\n    {\n      ...defaults,\n      ...cleanObject(ui)\n    },\n    opt => ({\n      largeur_traverse_h: opt.largeur_traverses,\n      largeur_traverse_b: opt.largeur_traverses,\n      ...opt\n    }))\n\n  $: data.opt = opt\n  $: data.ui  = ui\n  let state = {}\n\n  let zoom = 0.25\n\n  $: jeu_encastrement = opt.encastree ? opt.jeu_encastrement : 0\n\n  $: montant = new Piece()\n    .add_name(\"Montant\")\n    .add_features(opt.type == 'contre-profil' ? 'montant-cp' : 'montant')\n    .build(opt.hauteur - 2*jeu_encastrement, opt.largeur_montants, opt.epaisseur)\n  $: montant_g = montant\n    .add_name(\"gauche\")\n    .put(jeu_encastrement, jeu_encastrement, 0, 'yxz')\n  $: montant_d = montant\n    .add_name(\"droit\")\n    .put(jeu_encastrement + opt.largeur - opt.largeur_montants, jeu_encastrement, 0, 'yxz')\n\n  $: traverse =\n    (opt.type == 'contre-profil')  ? new Piece()\n      .add_name(\"Traverse\")\n      .add_features('traverse-cp')\n      .build(\n        opt.largeur - 2 * (opt.largeur_montants - opt.profondeur_profil) - 2*jeu_encastrement,\n        0,\n        opt.epaisseur):\n    (opt.type == 'tenon-mortaise') ? new Piece()\n      .add_name(\"Traverse\")\n      .add_features('traverse')\n      .build(\n        opt.largeur - 2 * opt.largeur_montants - 2*jeu_encastrement,\n        0,\n        opt.epaisseur)\n      .ajout_tenons(opt.profondeur_tenons):\n    new Piece();\n  $: traverse_xpos =\n    (opt.type == 'contre-profil')  ? opt.largeur_montants - opt.profondeur_profil:\n    (opt.type == 'tenon-mortaise') ? opt.largeur_montants - opt.profondeur_tenons:\n    0;\n  $: traverse_h = traverse\n    .add_name(\"haut\")\n    .build(null, opt.largeur_traverse_h)\n    .put(jeu_encastrement + traverse_xpos, jeu_encastrement + opt.hauteur-opt.largeur_traverse_h, 0, 'xyz')\n  $: traverse_b = traverse\n    .add_name(\"bas\")\n    .build(null, opt.largeur_traverse_b)\n    .put(jeu_encastrement + traverse_xpos, jeu_encastrement, 0, 'xyz')\n  $: panneau = (\n    (opt.type == 'contre-profil')  ? new Piece()\n      .build(\n        opt.largeur - 2 * (opt.largeur_montants - opt.profondeur_rainure + opt.jeu_rainure) - 2*jeu_encastrement,\n        opt.hauteur + 2 * (opt.profondeur_rainure - opt.jeu_rainure)\n          - opt.largeur_traverse_h - opt.largeur_traverse_b\n          - 2*jeu_encastrement,\n        opt.epaisseur_panneau):\n    (opt.type == 'tenon-mortaise') ? new Piece()\n      .build(\n        opt.largeur - 2 * (opt.largeur_montants - opt.profondeur_rainure + opt.jeu_rainure),\n        opt.hauteur + 2 * (opt.profondeur_rainure - opt.jeu_rainure)\n          - opt.largeur_traverse_h - opt.largeur_traverse_b,\n        opt.epaisseur_panneau):\n    new Piece())\n    .add_name(\"Panneau\")\n    .add_features('panneau')\n    .put(\n      jeu_encastrement + montant.largeur - opt.profondeur_rainure + opt.jeu_rainure,\n      jeu_encastrement + traverse_b.largeur - opt.profondeur_rainure + opt.jeu_rainure,\n      0,\n      'xyz')\n\n  $: pieces = [\n    opt.inclure_panneau ? panneau : null,\n    traverse_h, traverse_b,\n    montant_g, montant_d,\n  ].filter(x => x != null).map(p => p.multiply_que(opt.quantite))\n\n  $: state.pieces_group = new Group(pieces, `Porte ${data.name}`, 'Porte')\n    .add_features(`ferrage-${opt.ferrage}`)\n\n</script>\n\n<style>\n  form > * {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    max-width: 30em;\n  }\n  form > * > *:first-child {\n    flex-grow: 1;\n  }\n  hr.clear {\n    clear: both;\n    border: none;\n  }\n  table {\n    clear: both;\n  }\n</style>\n\n<Component bind:data={data} state={state} path={path} on:datachange>\n  <div slot=\"plan\">\n    <SVGDrawing pieces={pieces} name={`Porte ${data.name}`} />\n\n    <!--<img src=\"porte.svg\" />-->\n    <p>Zoom : <input type=range bind:value={zoom} min=0 max=1 step=.05> {zoom*100} %</p>\n    <svg\n        width=\"{zoom*opt.largeur + 25}\"\n        height=\"{zoom*opt.hauteur + 65}\">\n      <Cote zoom={zoom} x=20 y=0 dim={[\n          {\n            text: \"largeur: \",\n            start: 0,\n            length: opt.largeur,\n            row: 2,\n          },\n          {\n            text: \"lon. traverse: \",\n            start: traverse_h.x,\n            length: traverse_h.longueur,\n            row: 1,\n          },\n          {\n            start: montant_g.x,\n            length: montant_g.largeur,\n            row: 0,\n          },\n          {\n            start: montant_d.x,\n            length: montant_d.largeur,\n            row: 0,\n          }\n        ]} />\n      <Cote zoom={zoom} x=0 y=60 pos=left dim={[\n          {\n            text: \"hauteur: \",\n            start: 0,\n            length: opt.hauteur,\n            row: 0,\n          }\n        ]} />\n      <g transform=\"translate(20, {60 + zoom*opt.hauteur}) scale({zoom} {zoom})\">\n        {#each pieces as piece}\n          <SVGPiece piece={piece} pos=\"avant\" />\n        {/each}\n      </g>\n    </svg>\n  </div>\n\n  <div class=\"main\" slot=\"dim\">\n    <form>\n    <!-- buggy\n    <label><span>Quantité : </span><InputNumber min=1 bind:value={ui.quantite} def={defaults.quantite}/></label>\n    -->\n    <label>\n      <span>Ferrage : </span>\n      <InputSelect def={defaults.ferrage} bind:value={ui.ferrage} force={defaults.force_ferrage}>\n        <option value=\"aucun\">aucun</option>\n        <option value=\"charnieres\">charnières</option>\n      </InputSelect>\n    </label>\n    <label>\n      <span>Type : </span>\n      <InputSelect def={defaults.type} bind:value={ui.type}>\n        <option value=\"tenon-mortaise\">tenon et mortaise</option>\n        <option value=\"contre-profil\">contre profil</option>\n      </InputSelect>\n    </label>\n    <label><span>Largeur   : </span><InputNumber min=0 bind:value={ui.largeur} def={defaults.largeur} force={defaults.force_largeur}/> mm</label>\n    <label><span>Hauteur   : </span><InputNumber min=0 bind:value={ui.hauteur} def={defaults.hauteur} force={defaults.force_hauteur}/> mm</label>\n    <label><span>Épaisseur : </span><InputNumber min=0 bind:value={ui.epaisseur} def={defaults.epaisseur} force={defaults.force_epaisseur}/> mm</label>\n    <hr/>\n    <label><span>Largeur montants : </span><InputNumber min=0 bind:value={ui.largeur_montants} def={defaults.largeur_montants}/> mm</label>\n    <label><span>largeur traverses : </span><InputNumber min=0 bind:value={ui.largeur_traverses} def={defaults.largeur_traverses}/> mm</label>\n    <label><span>largeur traverse haut : </span><InputNumber min=0 bind:value={ui.largeur_traverse_h} def={opt.largeur_traverses}/> mm</label>\n    <label><span>largeur traverse bas : </span><InputNumber min=0 bind:value={ui.largeur_traverse_b} def={opt.largeur_traverses}/> mm</label>\n    <hr/>\n    <label><span>Épaisseur panneau : </span><InputNumber min=0 bind:value={ui.epaisseur_panneau} def={defaults.epaisseur_panneau}/> mm</label>\n    <label><span>Profondeur rainures : </span><InputNumber min=0 bind:value={ui.profondeur_rainure} def={defaults.profondeur_rainure}/> mm</label>\n    <label><span>Jeu paneau / rainure : </span><InputNumber min=0 bind:value={ui.jeu_rainure} def={defaults.jeu_rainure}/> mm</label>\n    {#if opt.type == 'tenon-mortaise' }\n    <label><span>Profondeur tenons : </span><InputNumber min=0 bind:value={ui.profondeur_tenons} def={defaults.profondeur_tenons}/> mm</label>\n    {:else if opt.type == 'contre-profil' }\n    <label><span>Profondeur profil : </span><InputNumber min=0 bind:value={ui.profondeur_profil} def={defaults.profondeur_profil}/> mm</label>\n    {/if}\n    <label><span>Inclure le paneau</span><InputCheckbox bind:checked={ui.inclure_panneau} def={defaults.inclure_panneau} /></label>\n    <hr/>\n    <label><span>Encastrée</span><InputCheckbox bind:checked={ui.encastree} def={defaults.encastree} /></label>\n    <label><span>jeu encastrement (tout autour) : </span><InputNumber min=0 bind:value={ui.jeu_encastrement} def={defaults.jeu_encastrement}/> mm</label>\n    </form>\n  </div>\n\n  <div slot=\"tables\">\n    <ListeDebit pieces={state.pieces_group} />\n  </div>\n</Component>\n",
    "<script>\n  import { onMount } from 'svelte';\n  import { cleanObject, pipeline } from '../utils.js';\n  import InputNumber from '../controls/InputNumber.svelte';\n  import InputCheckbox from '../controls/InputCheckbox.svelte';\n  import Component from '../Component.svelte';\n  import Cote from '../draw/Cote.svelte';\n  import Piece from '../pieces/piece.js';\n  import Group from '../pieces/Group.js';\n  import SVGPiece from '../pieces/SVGPiece.svelte';\n  import SVGDrawing from '../pieces/SVGDrawing.svelte';\n  import ListeDebit from '../ListeDebit.svelte'\n\n  export let path\n  export let initdata = {}\n\n  let data = {...initdata}\n\n  let defaults = {\n    quantite: 1,\n    largeur: 400,\n    hauteur: 150,\n    hauteur_tir_max: 150,\n    profondeur: 500,\n    epaisseur: 15,\n    profondeur_rainure: 9,\n    profondeur_queues_arrondes: 10,\n    jeu_rainure: 1,\n    jeu_lateral: 6,\n    jeu_dessous: 28,\n    jeu_dessus: 7,\n    epaisseur_fond: 10,\n    inclure_fond: true,\n    ...initdata.defaults\n  }\n\n  let opt = { ...initdata.opt }\n  let ui  = { ...(initdata.ui || initdata.opt) }\n  let tir = {}\n\n  $: tir = calculTiroir({\n      ...defaults,\n      ...cleanObject(ui)\n    })\n\n  $: opt = {\n      ...defaults,\n      ...tir,\n      ...cleanObject(ui),\n    }\n\n  $: data.opt = opt\n  $: data.ui  = ui\n  let state = {}\n\n  $: cote = new Piece()\n    .add_name(\"Coté\")\n    .add_features('cote')\n    .build(\n      opt.profondeur_tir - 2 * (opt.epaisseur - opt.profondeur_queues_arrondes),\n      opt.hauteur_tir,\n      opt.epaisseur)\n  $: cote_g = cote\n    .add_name(\"gauche\")\n    .put(\n      opt.jeu_lateral,\n      opt.jeu_dessous,\n      opt.epaisseur - opt.profondeur_queues_arrondes,\n      'zyx')\n  $: cote_d = cote\n    .add_name(\"droit\")\n    .put(\n      opt.jeu_lateral + opt.largeur_tir - opt.epaisseur,\n      opt.jeu_dessous,\n      opt.epaisseur - opt.profondeur_queues_arrondes,\n      'zyx')\n\n  $: face = new Piece()\n    .add_name(\"Face\")\n    .add_features('cote')\n    .build(opt.largeur_tir, opt.hauteur_tir, opt.epaisseur);\n  $: face_av = face\n    .add_name(\"avant\")\n    .put(\n      opt.jeu_lateral,\n      opt.jeu_dessous,\n      0,\n      'xyz')\n  $: face_ar = face\n    .add_name(\"arrière\")\n    .put(\n      opt.jeu_lateral,\n      opt.jeu_dessous,\n      opt.profondeur_tir - opt.epaisseur,\n      'xyz')\n\n  $: fond = new Piece()\n    .add_name(\"Fond tiroir\")\n    .add_features('panneau')\n    .build(\n      opt.largeur_tir - 2 * (opt.epaisseur - opt.profondeur_rainure + opt.jeu_rainure),\n      opt.profondeur_tir - (opt.epaisseur - opt.profondeur_rainure + opt.jeu_rainure),\n      opt.epaisseur_fond)\n    .put(\n      opt.jeu_lateral + opt.epaisseur - opt.profondeur_rainure + opt.jeu_rainure,\n      opt.jeu_dessous,\n      opt.epaisseur - opt.profondeur_rainure + opt.jeu_rainure,\n      'xzy')\n\n  $: pieces = [\n    opt.inclure_fond ? fond : null,\n    face_av, face_ar,\n    cote_g, cote_d,\n  ].filter(x => x != null).map(p => p.multiply_que(opt.quantite))\n\n  $: pieces_group = new Group(pieces, `Tiroir ${data.name}`, 'Tiroir')\n  $: state.pieces_group = pieces_group\n\n  function calculTiroir(opt){\n    let largeur_tir = opt.largeur - 2 * opt.jeu_lateral\n    let profondeur_tir = opt.profondeur - (opt.profondeur % 50)\n    let hauteur_tir = Math.min(opt.hauteur_tir_max, opt.hauteur - opt.jeu_dessous - opt.jeu_dessus)\n    return {largeur_tir, profondeur_tir, hauteur_tir}\n  }\n\n</script>\n\n<style>\n  form > * {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    max-width: 30em;\n  }\n  form > * > *:first-child {\n    flex-grow: 1;\n  }\n</style>\n\n<Component bind:data={data} state={state} path={path} on:datachange>\n  <div slot=\"plan\">\n    <SVGDrawing pieces={pieces_group} />\n  </div>\n\n  <div class=\"main\" slot=\"dim\">\n    <form>\n    <label><span>Quantité : </span><InputNumber min=1 bind:value={ui.quantite} def={defaults.quantite}/></label>\n    <hr/>\n    <label><span>Largeur logement   : </span><InputNumber min=0 bind:value={ui.largeur} def={defaults.largeur} force={defaults.force_largeur}/> mm</label>\n    <label><span>Hauteur logement  : </span><InputNumber min=0 bind:value={ui.hauteur} def={defaults.hauteur} force={defaults.force_hauteur}/> mm</label>\n    <label><span>Profondeur logement : </span><InputNumber min=0 bind:value={ui.profondeur} def={defaults.profondeur} force={defaults.force_profondeur}/> mm</label>\n    <hr/>\n    <label><span>Largeur   : </span><InputNumber min=0 bind:value={ui.largeur_tir} def={tir.largeur_tir}/> mm</label>\n    <label><span>Profondeur : </span><InputNumber min=0 bind:value={ui.profondeur_tir} def={tir.profondeur_tir}/> mm</label>\n    <label><span>Hauteur   : </span><InputNumber min=0 bind:value={ui.hauteur_tir} def={tir.hauteur_tir}/> mm</label>\n    <label><span>Hauteur max : </span><InputNumber min=0 bind:value={ui.hauteur_tir_max} def={defaults.hauteur_tir_max}/> mm</label>\n    <hr/>\n    <label><span>Profondeur queues d'arrondes : </span><InputNumber min=0 bind:value={ui.profondeur_queues_arrondes} def={defaults.profondeur_queues_arrondes}/> mm</label>\n    <label><span>Épaisseur : </span><InputNumber min=0 bind:value={ui.epaisseur} def={defaults.epaisseur} force={defaults.force_epaisseur}/> mm</label>\n    <label><span>Épaisseur fond : </span><InputNumber min=0 bind:value={ui.epaisseur_fond} def={defaults.epaisseur_fond}/> mm</label>\n    <label><span>Profondeur rainures : </span><InputNumber min=0 bind:value={ui.profondeur_rainure} def={defaults.profondeur_rainure}/> mm</label>\n    <label><span>Jeu paneau / rainure : </span><InputNumber min=0 bind:value={ui.jeu_rainure} def={defaults.jeu_rainure}/> mm</label>\n    <label><span>Inclure le fond</span><InputCheckbox bind:checked={ui.inclure_fond} def={defaults.inclure_fond} /></label>\n    </form>\n  </div>\n\n  <div slot=\"tables\">\n    <ListeDebit pieces={pieces_group} />\n  </div>\n</Component>\n"
  ],
  "names": [],
  "mappings": "AA4KE,oCAAM,CAAE,MAAM,8BAAC,CAAC,AACd,MAAM,CAAE,CAAC,AACX,CAAC,AACD,oBAAK,CAAC,qBAAM,CAAE,oBAAK,CAAC,MAAM,eAAC,CAAC,AAC1B,OAAO,CAAE,GAAG,AACd,CAAC,AACD,KAAK,8BAAC,CAAC,AACL,OAAO,CAAE,IAAI,CACb,kBAAkB,CAAE,IAAI,CAAC,IAAI,CAC7B,qBAAqB,CAAE,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAC1C,mBAAmB,CACjB,iBAAiB;MACjB,WAAW,CACb,SAAS,CAAE,GAAG,CAAC,MAAM,CACrB,MAAM,CAAE,IAAI;EACd,CAAC,AACD,sBAAsB,KAAK,8BAAC,CAAC,AAC3B,OAAO,CAAE,IAAI,CACb,qBAAqB,CAAE,IAAI,CAC3B,mBAAmB,CACjB,SAAS;MACT,MAAM,AACV,CAAC,AACD,KAAK,mCAAoB,CAAC,KAAK,eAAC,CAAC,AAC/B,IAAI,CAAE,CAAC,CAAC,CAAC,CAAC,IAAI;EAChB,CAAC,AACD,QAAQ,8BAAC,CAAC,AACR,OAAO,CAAE,GAAG,CACZ,SAAS,CAAE,OAAO,CAClB,gBAAgB,CAAE,IAAI,gBAAgB,CAAC,CACvC,aAAa,CAAE,KAAK,CAAC,GAAG,CAAC,IAAI,cAAc,CAAC,AAC9C,CAAC,AACD,kBAAkB,8BAAC,CAAC,AAClB,OAAO,CAAE,IAAI,CACb,aAAa,CAAE,OAAO,CACtB,kBAAkB,CAAE,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CACnC,qBAAqB,CAAE,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,AACxC,CAAC,AACD,KAAK,8BAAC,CAAC,AACL,SAAS,CAAE,IAAI,CACf,gBAAgB,CAAE,IAAI,gBAAgB,CAAC,CACvC,YAAY,CAAE,KAAK,CAAC,GAAG,CAAC,IAAI,cAAc,CAAC,CAC3C,QAAQ,CAAE,IAAI,CACd,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,UAAU,AACpB,CAAC,AACD,mCAAK,CAAC,AAAQ,EAAE,AAAE,CAAC,AACjB,YAAY,CAAE,GAAG,AACnB,CAAC,AAID,qCAAsB,CAAC,KAAK,eAAC,CAAC,AAC5B,OAAO,CAAE,IAAI,AACf,CAAC,AACD,KAAK,mCAAoB,CAAC,YAAY,eAAC,CAAC,AACtC,OAAO,CAAE,IAAI,AACf,CAAC,AACD,KAAK,8BAAC,CAAC,AACL,IAAI,CAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CACd,SAAS,CAAE,IAAI,CACf,QAAQ,CAAE,IAAI,CACd,YAAY,CAAE,OAAO,AACvB,CAAC,AAED,OAAO,KAAK,AAAC,CAAC,AACZ,mCAAK,CAAE,KAAK,8BAAC,CAAC,AACZ,OAAO,CAAE,KAAK,CAAC,UAAU,CACzB,QAAQ,CAAE,OAAO,CAAC,UAAU,CAC5B,MAAM,CAAE,IAAI,AACd,CAAC,AACH,CAAC;AC7ID,6CAAM,CAAC,AACL,OAAO,CAAE,IAAI,AACf,CAAC,AACD,UAAU,8CAAO,CAAE,iDAAU,OAAO,AAAC,CAAC,AACpC,MAAM,CAAE,IAAI,CACZ,OAAO,CAAE,IAAI,CACb,SAAS,CAAE,MAAM,CAAC,MAAM,AAC1B,CAAC,AAED,eAAe,uCAAC,CAAC,AACf,IAAI,CAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CACd,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,IAAI,AAChB,CAAC,AAED,EAAE,KAAK,uCAAC,CAAC,AACP,IAAI,CAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CACd,MAAM,CAAE,CAAC,CACT,gBAAgB,CAAE,IAAI,gBAAgB,CAAC,CACvC,aAAa,CAAE,KAAK,CAAC,GAAG,CAAC,IAAI,cAAc,CAAC,AAC9C,CAAC,AACD,EAAE,+BAAK,CAAG,4BAAE,WAAW,AAAC,CAAC,AACvB,YAAY,CAAE,KAAK,CAAC,GAAG,CAAC,IAAI,cAAc,CAAC,AAC7C,CAAC,AACD,EAAE,+BAAK,CAAG,EAAE,0BAAC,CAAC,AACZ,UAAU,CAAE,KAAK,CAAC,GAAG,CAAC,IAAI,cAAc,CAAC,CACzC,WAAW,CAAE,KAAK,CAAC,GAAG,CAAC,IAAI,cAAc,CAAC,CAC1C,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,CACV,UAAU,CAAE,GAAG,CACf,OAAO,CAAE,MAAM,AACjB,CAAC,AACD,EAAE,kBAAK,CAAG,eAAE,CAAG,CAAC,aAAC,CAAC,AAChB,OAAO,CAAE,CAAC,CAAC,GAAG,AAChB,CAAC,AACD,EAAE,kBAAK,CAAG,eAAE,CAAG,CAAC,OAAO,aAAC,CAAC,AACvB,gBAAgB,CAAE,KAAK,AACzB,CAAC,AAEO,YAAY,AAAC,CAAC,yCAAe,2BAAG,KAAK,oBAAoB,CAAC,AAAC,CAAC,AAClE,OAAO,CAAE,IAAI,AACf,CAAC,AAEO,WAAW,AAAC,CAAC,yCAAe,2BAAG,KAAK,mBAAmB,CAAC,AAAC,CAAC,AAChE,OAAO,CAAE,IAAI,AACf,CAAC,AAEO,cAAc,AAAC,CAAC,yCAAe,2BAAG,KAAK,sBAAsB,CAAC,AAAC,CAAC,AACtE,OAAO,CAAE,IAAI,AACf,CAAC,AAEO,gBAAgB,AAAC,CAAC,yCAAe,2BAAG,KAAK,oBAAoB,CAAC,KAAK,wBAAwB,CAAC,AAAC,CAAC,AACpG,OAAO,CAAE,IAAI,AACf,CAAC,AACO,gBAAgB,AAAC,CAAC,yCAAe,CAAG,oBAAoB,0BAAC,CAAC,AAChE,KAAK,CAAE,CAAC,CACR,IAAI,CAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CACd,OAAO,CAAE,KAAK,CACd,YAAY,CAAE,KAAK,CAAC,GAAG,CAAC,IAAI,cAAc,CAAC,CAC3C,QAAQ,CAAE,IAAI,CACd,MAAM,CAAE,UAAU,AACpB,CAAC,AACO,gBAAgB,AAAC,CAAC,yCAAe,CAAG,wBAAwB,0BAAC,CAAC,AACpE,KAAK,CAAE,CAAC,CACR,IAAI,CAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CACd,OAAO,CAAE,KAAK,CACd,QAAQ,CAAE,IAAI,AAChB,CAAC,AACO,gBAAgB,AAAC,CAAC,eAAe,uCAAC,CAAC,AACzC,OAAO,CAAE,IAAI,CACb,SAAS,CAAE,GAAG,CAAC,MAAM,AACvB,CAAC,AAEO,gBAAgB,AAAC,CAAC,yCAAe,CAAG,0BAAE,CAAC,AAC7C,OAAO,CAAE,IAAI,AACf,CAAC,AACO,gBAAgB,AAAC,CAAC,yCAAe,CAAG,oBAAoB,0BAAC,CAAC,AAChE,KAAK,CAAE,CAAC,CACR,IAAI,CAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CACd,OAAO,CAAE,KAAK,CACd,YAAY,CAAE,KAAK,CAAC,GAAG,CAAC,IAAI,cAAc,CAAC,CAC3C,QAAQ,CAAE,IAAI,CACd,MAAM,CAAE,UAAU,AACpB,CAAC,AACO,gBAAgB,AAAC,CAAC,yCAAe,CAAG,mBAAmB,0BAAC,CAAC,AAC/D,KAAK,CAAE,CAAC,CACR,IAAI,CAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CACd,OAAO,CAAE,KAAK,CACd,QAAQ,CAAE,IAAI,AAChB,CAAC,AACO,gBAAgB,AAAC,CAAC,eAAe,uCAAC,CAAC,AACzC,OAAO,CAAE,IAAI,CACb,SAAS,CAAE,GAAG,CAAC,MAAM,AACvB,CAAC,AAED,OAAO,KAAK,AAAC,CAAC,AACZ,iDAAU,CAAE,sDAAe,CAAE,yCAAe,CAAG,0BAAE,CAAC,AAChD,OAAO,CAAE,KAAK,CAAC,UAAU,CACzB,QAAQ,CAAE,OAAO,CAAC,UAAU,AAC9B,CAAC,AACH,CAAC;AC1GD,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,cAAC,CAAC,AACf,KAAK,CAAE,GAAG,AACZ,CAAC,AACD,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,cAAC,CAAC,AACf,KAAK,CAAE,GAAG,AACZ,CAAC;ACRD,oBAAM,CAAC,KAAK,cAAC,CAAC,AACZ,OAAO,CAAE,MAAM;EACjB,CAAC;AC7ED,SAAS,cAAC,CAAC,AACT,WAAW,CAAE,IAAI,AACnB,CAAC;ACSD,MAAM,MAAM,cAAC,CAAC,AACZ,UAAU,CAAE,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,AAC/B,CAAC;ACsiCD,gCAAI,CAAG,KAAK,4BAAC,CAAC,AACZ,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,GAAG,CACnB,SAAS,CAAE,MAAM,CACjB,SAAS,CAAE,IAAI,AACjB,CAAC,AACD,kBAAI,CAAG,mBAAK,CAAG,cAAC,YAAY,AAAC,CAAC,AAC5B,SAAS,CAAE,CAAC,AACd,CAAC,AAKD,EAAE,0CAAC,CAAC,AACF,cAAc,CAAE,GAAG,AACrB,CAAC,AAYD,OAAO,0CAAC,CAAC,AACP,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,GAAG,CACnB,eAAe,CAAE,MAAM,CACvB,MAAM,CAAE,KAAK,AACf,CAAC,AACD,mCAAO,CAAC,QAAQ,4BAAC,CAAC,AAChB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,KAAK,CAAE,GAAG,AACZ,CAAC,AACD,mCAAO,CAAC,QAAQ,CAAC,OAAO,4BAAC,CAAC,AACxB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,CACtB,UAAU,CAAE,MAAM,AACpB,CAAC,AACD,mCAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,4BAAC,CAAC,AAC1C,MAAM,CAAE,KAAK,AACf,CAAC,AAED,mCAAO,CAAC,OAAO,aAAa,4BAAW,CAAC,AAAC,UAAU,CAAE,GAAG,CAAC,KAAK,CAAC,KAAK,AAAE,CAAC,AACvE,mCAAO,CAAC,OAAO,YAAY,4BAAY,CAAC,AAAC,aAAa,CAAE,GAAG,CAAC,KAAK,CAAC,KAAK,AAAE,CAAC,AAC1E,mCAAO,CAAC,OAAO,uBAAuB,4BAAC,CAAC,AAAC,WAAW,CAAE,GAAG,CAAC,MAAM,CAAC,KAAK,AAAE,CAAC,AACzE,mCAAO,CAAC,OAAO,sBAAsB,4BAAE,CAAC,AAAC,YAAY,CAAE,GAAG,CAAC,MAAM,CAAC,KAAK,AAAE,CAAC,AAC1E,mCAAO,CAAC,OAAO,eAAe,4BAAS,CAAC,AAAC,WAAW,CAAE,GAAG,CAAC,KAAK,CAAC,KAAK,AAAE,CAAC,AACxE,mCAAO,CAAC,OAAO,cAAc,4BAAU,CAAC,AAAC,YAAY,CAAE,GAAG,CAAC,KAAK,CAAC,KAAK,AAAE,CAAC,AACzE,mCAAO,CAAC,OAAO,YAAY,4BAAY,CAAC,AAAC,gBAAgB,CAAE,IAAI,AAAE,CAAC,AAElE,aAAa,0CAAC,CAAC,AACb,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,GAAG,CACnB,WAAW,CAAE,UAAU,AACzB,CAAC,AAED,yCAAa,CAAG,4BAAE,CAAC,AACjB,MAAM,CAAE,KAAK,AACf,CAAC;ACplCD,kCAAI,CAAG,8BAAE,CAAC,AACR,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,GAAG,CACnB,SAAS,CAAE,MAAM,CACjB,SAAS,CAAE,IAAI,AACjB,CAAC,AACD,mBAAI,CAAG,eAAC,CAAG,eAAC,YAAY,AAAC,CAAC,AACxB,SAAS,CAAE,CAAC,AACd,CAAC;ACRD,kCAAI,CAAG,8BAAE,CAAC,AACR,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,GAAG,CACnB,SAAS,CAAE,MAAM,CACjB,SAAS,CAAE,IAAI,AACjB,CAAC,AACD,mBAAI,CAAG,eAAC,CAAG,eAAC,YAAY,AAAC,CAAC,AACxB,SAAS,CAAE,CAAC,AACd,CAAC;ACiFD,kCAAI,CAAG,8BAAE,CAAC,AACR,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,GAAG,CACnB,SAAS,CAAE,MAAM,CACjB,SAAS,CAAE,IAAI,AACjB,CAAC,AACD,mBAAI,CAAG,eAAC,CAAG,eAAC,YAAY,AAAC,CAAC,AACxB,SAAS,CAAE,CAAC,AACd,CAAC;AChBD,kCAAI,CAAG,8BAAE,CAAC,AACR,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,GAAG,CACnB,SAAS,CAAE,MAAM,CACjB,SAAS,CAAE,IAAI,AACjB,CAAC,AACD,mBAAI,CAAG,eAAC,CAAG,eAAC,YAAY,AAAC,CAAC,AACxB,SAAS,CAAE,CAAC,AACd,CAAC"
}